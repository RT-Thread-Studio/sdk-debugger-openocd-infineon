#
# Copyright (C) <2024-2025>
#   <Cypress Semiconductor Corporation (an Infineon company)>
#
# Subroutines for CAT1D category of microcontrollers.
# The definitions can be overwritten from the family-specific scripts.

namespace eval cat1d {

	namespace import ::arm::*
	namespace import ::ifx::*
	namespace import ::cat1::*

	variable dap
	variable ap


	###########################################################################
	# Acquisition
	###########################################################################

	# Device acquire procedure
	proc acquire_cat1d { mode } {
		log_proc_entry
		set result 1

		if {$::ENABLE_ACQUIRE} {

			# Use SYS-AP for the target acquisition
			targets $::CHIPNAME.sys
			catch {$::CHIPNAME.sys arp_examine}

			# Acquire in Test mode
			if {$mode == "acquire_and_check"} {
				set result [acquire_test_mode]
			}

			# Check Test mode acquisition result: poll for acknowledge code in SRAM
			if {$result} {
				set result 0; set t_end [expr {[ms] + $::TIMEOUT_BOOT_COMPLETE}]
				if [ catch {
					while {[ms] < $t_end} {
						if {[mrw $::BOOT_STATUS_ADDR] == $::BOOT_STATUS_LISTWND} {
							set result 1
							break
						}
					}
				} ] { echo [format "Warn : Cannot read boot status @0x%08X" $::BOOT_STATUS_ADDR]}
			}

			if {$result} {echo "** Target acquired in Test Mode" } \
			elseif {$mode == "acquire_and_check"} { puts stderr "** Acquisition in Test Mode FAILED!"} \
			else { echo "** Target is not in Test Mode" }
		}

		# If CPU-AP is closed, acquire in WFA and send the debug token (certificate)
		if {$result} {
			if {$::ENABLE_CM33 && ![is_cpu_ap_open $::CHIPNAME.sys33]} {

				set ::DEBUG_CERTIFICATE_REQUIRED 1
				echo "** CM33 AP is closed, sending debug certificate"
				set result 0
				if {![info exists ::DEBUG_CERTIFICATE]} {
					puts stderr "** No certificate specified, examination skipped"
					puts stderr "** Use 'DEBUG_CERTIFICATE' variable to specify certificate filename with full path"
				} elseif  {![file exists $::DEBUG_CERTIFICATE]} {
					puts stderr "** Could not open certificate file '$::DEBUG_CERTIFICATE'"
				} elseif [catch {set result [load_debug_token $::DEBUG_CERTIFICATE $::DEBUG_CERTIFICATE_ADDR]}] {
					puts stderr "** Error sending debug certificate, examination skipped"
				}

				if {$result} {
					# Events specific for the WFA and the debug token flow
					$::CHIPNAME.cm33 configure -event reset-assert "event_cm33_reset_assert_debug_token"
				}
			} else {
				set ::DEBUG_CERTIFICATE_REQUIRED 0
			}
		}

		# Set CPU target (CM33-AP or CM55-AP) by default for regular operations
		if {$result} {
			if {$::ENABLE_CM33} {
				$::CHIPNAME.cm33 arp_examine
				$::CHIPNAME.cm33 arp_poll
				$::CHIPNAME.cm33 arp_poll
				targets $::CHIPNAME.cm33
			}
			if {$::ENABLE_CM55} {
				$::CHIPNAME.cm55 arp_examine
				$::CHIPNAME.cm55 arp_poll
				$::CHIPNAME.cm55 arp_poll
				if {!$::ENABLE_CM33} {
					targets $::CHIPNAME.cm55
				}
			}
		}

		log_proc_return $result
		return $result
	}

	# Acquires the device in test mode
	proc acquire_test_mode { } {
		log_proc_entry
		set result 0

		if {![using_jtag] && [adapter name] == "kitprog3"} {
			# Test mode acquisition using KitProg3's vendor command
			set result [expr {![catch {kitprog3 acquire_psoc}]}]

		} else {

			# Test mode acquisition without using the KitProg3 vendor commands
			# 1. Prereset - do hardware reset (XRES)
			# 2. Handshake - wait while SWJ pins are enabled after the reset so we can connect to DAP
			# 3. Set TEST_MODE bit in SRSS->TST_MODE register.
			#    Try with timeout since, even if the SWJ pins are enabled, the rest of the debug features,
			#    including memory access, may not be fully configured yet until the boot code finishes all
			#    system configuration and starts the Listen Window

			echo "** Attempting to soft-acquire chip in Test Mode..."
			push_log_settings
			push_polling

			reset_config srst_only; adapter assert srst; sleep 100; adapter deassert srst; reset_config none
			set result 0; set t_end [expr {[ms] + $::TIMEOUT_RESET_HANDSHAKE + $::TIMEOUT_BOOT_COMPLETE}]
			set ::is_in_dap_init 1
			while {[ms] < $t_end} {
				if {[catch {dap init; mww $::TST_MODE $::TST_MODE_TEST_MODE}] == 0} {
					set result 1
					break
				}
			}
			unset ::is_in_dap_init

			pop_polling
			pop_log_settings

			# The steps above are time-critical and must be executed without delays immediately after reset.
			# No hurry for further steps - target already acquired in Test mode
		}

		log_proc_return $result
		return $result
	}

	# Acquires in WFA mode and loads the debug token (certificate)
	proc load_debug_token { cert_path address {use_sysresetreq 0}} {
		log_proc_entry
		push_log_settings

		set sysap $::CHIPNAME.sys
		set cm33  $::CHIPNAME.cm33
		set cm55  $::CHIPNAME.cm55
		push_polling

		# Initial clearance
		# BOOT_DLM_STATUS survives System Reset, so clear it
		# If target is already in WFA mode, clear WFA request and issue reset
		catch {write32 $sysap $::BOOT_DLM_STATUS 0}
		catch {if [expr {[read32 $sysap $::BOOT_DLM_CTL] & $::BOOT_DLM_CTL_WFA}] { catch {
					write32 $sysap $::BOOT_DLM_CTL $::BOOT_DLM_CTL_WFA
					write32 $sysap $::RES_SOFT_CTL 1
					if {[using_jtag]} {
						dap_handshake
					}
				}
			}
		}

		# Request to BootROM
		# Set WFA request: BOOT_DLM_CTL.REQUEST = 0x2
		# And issue soft reset using either AIRCR.SYSRESETREQ or RES_SOFT_CTL.TRIGGER_SOFT = 0x1
		catch {write32 $sysap  $::BOOT_DLM_CTL 2}
		if {$use_sysresetreq && $::ENABLE_CM33} {
			catch { write32 $cm33 0xE000ED0C 0x05FA0004 }
		} else {
			catch { write32 $sysap $::RES_SOFT_CTL 1 }
		}
		if {[using_jtag]} {
			dap_handshake
		}			

		# Set TEST_MODE bit, just in case
		set ret 0; set t_end [expr {[clock milliseconds] + $::TIMEOUT_BOOT_COMPLETE}]
		while {[clock milliseconds] < $t_end} {
			if [catch {write32 $sysap $::TST_MODE $::TST_MODE_TEST_MODE}] continue
			set ret 1
			break
		}

		# Check for the status that the boot code is ready for loading the certificate (BOOT_DLM_CTL.WFA = 1)
		set ret 0; set t_end [expr {[clock milliseconds] + $::TIMEOUT_BOOT_COMPLETE}]
		while {[clock milliseconds] < $t_end} {
			if {![catch {read32 $sysap $::BOOT_DLM_CTL} boot_dlm_ctl] && \
			     (($boot_dlm_ctl & $::BOOT_DLM_CTL_WFA) == $::BOOT_DLM_CTL_WFA)} {
				set ret 1
				break
			}
			sleep 50
		}

		pop_polling
		if {$ret} {echo "** Target acquired in WFA mode"} \
		else {puts stderr "** Acquisition in WFA mode FAILED!"}

		# Load the debug certificate into SRAM and set BOOT_DLM_CTL2 with start address of debug certificate
		$sysap arp_examine
		write32 $sysap $::BOOT_DLM_CTL2 $address
		set tgt_backup [target current]
		targets $sysap
		load_image $cert_path $address
		targets $tgt_backup

		# Clear WFA request (BOOT_DLM_CTL.WFA = 0) to let the BootROM proceed with the certificate validation
		# Then check the verification status ( BOOT_DLM_STATUS = CYBOOT_DEBUG_TOKEN_VALID )
		push_polling
		catch {write32 $sysap $::BOOT_DLM_CTL 0}
		set ret 0; set t_end [expr {[clock milliseconds] + $::TIMEOUT_BOOT_COMPLETE}]
		while {[clock milliseconds] < $t_end} {
			if {![catch {read32 $sysap $::BOOT_DLM_STATUS} status] && ($status == 0x0D500081)} {
				set ret 1
				break
			}
			sleep 50
		}
		pop_polling
		catch {write32 $sysap $::TST_MODE 0}

		# Check APs are opened and examine targets
		if {$::ENABLE_CM33} {
			echo "** Waiting for $cm33 ..."
			if {[poll_cpu_ap_open $::CHIPNAME.sys33 $::TIMEOUT_BOOT_COMPLETE]} {
				$cm33 arp_examine
				$cm33 arp_poll
				$cm33 arp_poll
				# TODO: CM55 to CM33 dependency
				if {$::ENABLE_CM55} {
					$cm55 arp_examine
					$cm55 arp_poll
					$cm55 arp_poll
				}
				set ret 1
			} else {
				# TODO: Implement get/print of status variable name from the dictionary
				puts stderr "** CM33 AP still closed, DLM Status: [mrw $::BOOT_DLM_STATUS]"
				set ret 0; error {}
			}
		}

		pop_log_settings
		log_proc_return $ret
		return $ret
	}

	proc event_cm33_reset_assert_debug_token { } {
		log_proc_entry

		if {![info exists ::f_acquire_skip_cm33_reset_assert]} {

			push_log_settings
			set result 0; set t_end [expr {[ms] + $::TIMEOUT_RESET_HANDSHAKE + $::TIMEOUT_BOOT_COMPLETE}]
			while {[ms] < $t_end} {
				if {[catch {write32 $::CHIPNAME.sys $::TST_MODE $::TST_MODE_TEST_MODE} {dap_handshake}] == 0} {
					$::CHIPNAME.cm33 arp_examine
					$::CHIPNAME.cm33 arp_poll
					$::CHIPNAME.cm33 arp_poll
					$::CHIPNAME.cm33 cortex_m vector_catch reset
					load_debug_token $::DEBUG_CERTIFICATE $::DEBUG_CERTIFICATE_ADDR 1
					$::CHIPNAME.cm33 cortex_m vector_catch none
					set result 1
					break
				}
			}
			pop_log_settings

			if {$result} {
				targets $::CHIPNAME.cm33
				enable_cpu
			}
		}

		log_proc_return
	}


	###########################################################################
	# CPU pre-initialization
	###########################################################################

	proc enable_cpu { { target ""} } {
		log_proc_entry

		if { $::ENABLE_CM55 && ($target eq "" || ([string first "cm55" $target] != -1)) } {
			enable_cpu_cm55_domain
			enable_cpu_cm55
		}

		log_proc_return
	}

	# Enables CM55, which is turned off after reset and requires following initialization for debugging:
	# 1. Power up: set dependency between SYSTEM and APPCPUSS_CORE0 power domains to power up the core region:
	#    Write to PD_ON field in Power Domain Dependency Sense Register.
	# 2. Enable debugging for the M55APPCPUSS by writing following bits to APPCPUSS_AP_CTL register:
	#    [0] CM55_0_ENABLE     Enables the CM55_0 AP interface:
	#    [4] CM55_0_DBG_ENABLE Enables invasive debug features.
	#    [5] CM55_0_NID_ENABLE Enables all trace and non-invasive debug features.
	# Normally, this is done by the CM33 application (cm33_ns or cm33_s) by calling `Cy_SysEnableCM55` or in the boot code.
	# If not done (e.g. CM33 application hasn't started or did not call `Cy_SysEnableCM55` yet),
	# the debugger has to do it on its own, via AP-CM33.
	proc enable_cpu_cm55_domain {} {
		log_proc_entry

		if {$::ENABLE_CM55 && ![info exists ::do_not_touch_cm55]} {
			push_log_settings
			set tgt $::CHIPNAME.cm33
			set pd_sense_addr [addr_to_sorns $tgt $::PWRMODE_PD6_PD_SENSE]
			set ap_ctrl_addr  [addr_to_sorns $tgt $::APPCPUSS_AP_CTL]

			if [ catch {
				set pd_sense [read32 $tgt $pd_sense_addr]
				set ap_ctrl  [read32 $tgt $ap_ctrl_addr]

				if [ catch {
					if {[ expr {($pd_sense & $::PD_SENSE_PD_ON_CM55) != $::PD_SENSE_PD_ON_CM55} ]} {
						echo "Info : \[$tgt\] Configuring CM55 power dependencies"
						write32 $tgt $pd_sense_addr [expr {$pd_sense | $::PD_SENSE_PD_ON_CM55}]
					}
					if {[ expr {($ap_ctrl & $::APPCPUSS_AP_CTL_CM55_EN) != $::APPCPUSS_AP_CTL_CM55_EN} ]} {
						echo "Info : \[$tgt\] Enabling CM55 debug features"
						write32 $tgt $ap_ctrl_addr [expr {$ap_ctrl | $::APPCPUSS_AP_CTL_CM55_EN}]
					}
				}] { echo "Warn : \[$tgt\] Cannot write CM55 power/control registers" }

			} ] { echo "Info : \[$tgt\] Cannot read CM55 power/control registers - skipping setup" }

			pop_log_settings
		}

		log_proc_return
	}

	# Enables CM55 after reset: clear CPU_WAIT and set 'safe' initial state
	proc enable_cpu_cm55 {} {
		log_proc_entry

		if {$::ENABLE_CM55 && ![info exists ::do_not_touch_cm55]} {
			push_log_settings

			# Re-examine CPUs state
			set cm33 $::CHIPNAME.cm33
			$cm33 arp_examine
			$cm33 arp_poll
			$cm33 arp_poll
			set cm55 $::CHIPNAME.cm55
			$cm55 arp_examine
			$cm55 arp_poll
			$cm55 arp_poll
			set tgt_backup [target current]
			log_debug_cpu_stat

			if {[catch {

				# TODO: RESET RUN problems:
				# Can't read MXCM55_CM55_CTL after reset run, neither at 0x44160000 nor at 0x54160000 address
				# Looks like because of protection changes made by resumed apps
				# set cpu_ctrl_addr [addr_to_sorns $cm33 $::MXCM55_CM55_CTL]
				set cpu_ctrl_addr $::MXCM55_CM55_CTL
				set cpu_ctrl [read32 $cm33 $cpu_ctrl_addr]
				set cpu_wait [expr {($cpu_ctrl & 0x10) != 0 }]
				if {$cpu_wait} {
					echo "Info : \[$cm55\] Clearing CPU_WAIT"

					# Set Vector Catch and clear CPU_WAIT for CM55
					$cm55 cortex_m vector_catch reset
					write32 $cm33 $cpu_ctrl_addr [expr {$cpu_ctrl & ~0x10}]

					# Re-examine CPU state, ensure halted, and clear vector catch
					$cm55 arp_examine
					$cm55 arp_poll
					$cm55 arp_poll
					$cm55 arp_halt
					set is_halted [poll_halted $cm55 500]
					$cm55 cortex_m vector_catch none
					log_debug_cpu_stat "Targets state (after clearing CPU_WAIT):"

					if {$is_halted} {
						# Restore THUMB bit in xpsr
						set xpsr_val [expr {[dict values [$cm55 get_reg xpsr]] | 0x01000000}]
						$cm55 set_reg "xpsr $xpsr_val"

						# Set 'safe' initial state for CM55 core.
						# If CM55 was in a WAIT state after the reset, it means that there was no application running yet to configure CM55 core (typically is done in cm33_ns).
						# Because of that, the main CPU registers may contain the weird values, which makes the debugger nervous. So we have to:
						# 1. Let the CPU execute the endless loop instruction in a 'safe' memory location.
						#    This is to avoid faults when the debugger attempts to make a step or lets the CPU run.
						#    For CM55 core, the safe locations are the CM55_ITCM_INTERNAL (0x00000000) and CM55_DTCM_INTERNAL (0x20000000) memory regions.
						#    Other memories may not be allowed for CM55-AP after the reset.
						# 2. Set the 'safe' initial values in the main CPU registers to avoid "Failed to read memory" errors while starting the debug sessions.
						if {[dict values [$cm55 get_reg lr]] & 0xF0000000 == 0xF0000000} {
							puts -nonewline "Info : \[$cm55\] Pre-initializing: "
							set ENDLESS_LOOP_INSTR 0xE7FEE7FE
							write32 $cm55 $::CM55_ENDLESS_LOOP_ADDR $ENDLESS_LOOP_INSTR
							set pc  [expr {$::CM55_ENDLESS_LOOP_ADDR | 0x1}]
							set sp  0x100; set msp 0x100
							set msg "Info : \[%s\] Pre-initializing: "
							puts [format "pc: 0x%x, sp: 0x%x, msp: 0x%x" $pc $sp $msp]
							$cm55 set_reg "pc $pc sp $sp msp $msp"

							# TODO: Resume/halt is a workaround for 'set_reg', which does not immediately writes to target, but uses internal cache
							# Moreover, any 'get_reg' command with '-force' parameter will overwrite values set by set_reg if not flushed yet
							# The MR for this issue is tracked in the OpenOCD mainline: https://review.openocd.org/c/openocd/+/8070/15
							# Check we can flush the cache manually
							targets $cm55
							resume
							$cm55 arp_halt
							poll_halted $cm55 100
							targets $tgt_backup
						}
						log_debug_cpu_stat "Targets state (after changing core registers):"

					} else { log_debug "Cannot halt core after clearing CPU_WAIT. Skipping pre-initialization" }

					# Re-examine CPU state
					$cm55 arp_examine
					$cm55 arp_poll
					$cm55 arp_poll
					log_debug_cpu_stat
				}

			} msg ]} { echo "Warn : \[$cm55\] Failed to clear CPU_WAIT:\n$msg" }

			pop_log_settings
		}

		log_proc_return
	}


	###########################################################################
	# Applications debugging
	###########################################################################

	# Reset and halt CPU at the Reset Handler for debugging
	# Supported targets: `cm33`, `cm33_ns`, `cm55`
	# Supported modes: `reset`, `restart`, `attach`, `multi`
	proc reset_halt { target {mode reset}} {
		log_proc_entry

		if {[string first "cm33" $target] != -1} {
			if {[string first "_ns" $target] != -1} {
				set mode ${mode}_ns
			}
			set ret [reset_halt_cm33 $mode]
		} elseif {[string first "cm55" $target] != -1} {
			set ret [reset_halt_cm55 $mode]
		}

		# Print CPU status if it was not printed in the inner procedure while DEBUG_LOG == 1
		if {![debug_log_enabled]} {
			cpu_stat
		}
		log_proc_return $ret
		return $ret
	}

	# Reset and halt CM33 at the Reset Handler for debugging
	# Supported modes: `reset[_ns]` or `restart[_ns]`
	# Note: Do not call this procedure directly from command line, use `reset_halt` instead
	proc reset_halt_cm33 { {mode reset} } {
		log_proc_entry

		# Check major configuration issues
		set result $::ENABLE_CM33
		if {!$result} {
			puts stderr "Error: Use `set ENABLE_CM33 1` to enable the core for debugging"
			log_proc_return $result
			return $result
		}

		# Check Attach debug started
		# Ignore first time - do nothing to disturb already started target
		# For next calls - do normal reset/restart
		if {[string first "attach" $mode] != -1} {
			global DEBUG_MULTI_CORE
			if {![info exists DEBUG_MULTI_CORE]} {
				set DEBUG_MULTI_CORE 1
				log_proc_return 1
				return 1
			}
		}

		# Prepare for start
		set tgt_backup [target current]
		set tgt $::CHIPNAME.cm33
		echo "Info : \[$tgt\] Initializing \`$mode\` debug"
		log_debug_cpu_stat
		targets $tgt
		set restart_mode [expr {[string first "restart" $mode] != -1}]
		set ns_app_needed [expr {[string first "_ns" $mode] != -1}]

		# Check we must force full restart and re-acquire regardless of the user's preferences, IF:
		# 1) Debug certificate is required (e.g. in PRODUCTION LCS with corresponding policies),
		#    re-acquire the device and send the certificate while doing Reset/Restart during the Debug or Attach.
		# 2) Other bad things happened for the debugger, e.g. security settings changed so we can't read basic resources like LCS
		set restart_needed $restart_mode
		if {!$restart_needed} {

			# TODO: Check we can skip re-acquire with a certificate for simple use cases, e.g. when we debug CM33 and it is already halted at reset handler or in boot code
			# The flag is set earlier if the acquisition was already performed
			if {[info exists ::DEBUG_CERTIFICATE_REQUIRED]} {
				if {$::DEBUG_CERTIFICATE_REQUIRED} {
					echo "Info : \[$tgt\] Forcing restart to re-send the debug token"
					set restart_needed 1
				}

			# If there was no acquisition performed previously (e.g. for Attach), check the LCS
			} elseif {![catch { set lcs [read32 $tgt [addr_to_sorns $tgt $::DECODED_LCS_DATA]]}]} {
				if {[decode_lcs $lcs] eq "PRODUCTION"} {
					echo "Info : \[$tgt\] Forcing restart to re-send the debug token in PRODUCTION LCS"
					set restart_needed 1
				}

			# If LCS reading failed, we must be using JTAG or some other bad things happened for the debugger,
			# so re-acquire the device anyway
			} else {
				echo "Info : \[$tgt\] Forcing restart due to protection settings: cannot read LCS"
				set restart_needed 1
			}			
		}

		# Do full restart/re-acquire if:
		#   a) Requested by user
		#   b) Debug certificate required in PRODUCTION LCS
		#   c) Could not hit NS_Reset_Handler when we need it
		#   d) Could not read basic resources, like LCS
		set restart_done 0
		set sysrst_done 0
		if {$restart_needed} {
			if {!$::ENABLE_ACQUIRE} {
				set ::ENABLE_ACQUIRE 1
				kitprog3_acquire_config $::TIMEOUT_RESET_HANDSHAKE
			}
			set ::f_acquire_skip_cm33_reset_assert 1
			set result [acquire_cat1d acquire_and_check]
			unset ::f_acquire_skip_cm33_reset_assert
			set restart_done 1
			set restart_needed 0
		}

		push_log_settings

		while {$result} { ; # Loop is just to avoid multiple nestings
			set result 0
			set is_s_reset_handler 0
			set is_ns_reset_handler 0

			###########################################################################################################
			# Check for NS_Reset_Handler
			###########################################################################################################

			if {$ns_app_needed} {

				if {![is_secure_domain $tgt]} {

					# If we are in Non-Secure domain, quickly check if we already at NS_Reset_Handler
					# or can move to it harmlessly without restart
					set is_ns_reset_handler [expr { [$tgt curstate] eq "halted" && ![catch {
							set pc      [expr {[dict values [$tgt get_reg pc]] & ~1 }]
							set vt_addr [expr {[read32 $tgt 0xE000ED08] & 0xFFFFFF80}]
							set vt_rst  [expr {[read32 $tgt [expr {$vt_addr + 4}]] & ~1 }]
						}] && $vt_addr != 0 && ![is_secure_addr $vt_addr] && ![is_secure_addr $vt_rst] && ![is_secure_addr $pc]}]
					if {$is_ns_reset_handler && ($pc != $vt_rst)} {
						# TODO: Local reset + VC is needed since the new debug session will use old MSP, etc.
						set is_ns_reset_handler [move_to_reset_handler $tgt]
					}
				}

				if {$is_ns_reset_handler} {
					echo "Info : \[$tgt\] Halted at Non-Secure reset handler"
					set result 1
					break
				}
			}

			###########################################################################################################
			# Proceed to S_Reset_Handler of user`s app
			###########################################################################################################

			set timeout_boot $::TIMEOUT_BOOT_COMPLETE
			set timeout_app $::TIMEOUT_USER_APP
			set timeout_max [expr {$timeout_boot + $timeout_app}]

			# Check if acquired in boot (E.g. at Extended boot reset handler, or halted before listen window ends, or in IDLE loop)
			# If yes, resume to catch at S_Reset_Handler of user`s app
			set is_s_reset_handler [boot_to_s_reset_handler]
			if {!$is_s_reset_handler} {

				# If not, do Soft-reset + Vector Catch and proceed to S_Reset_Handler

				# TODO: This condition is due to hard fault when using with local reset from Non-Secure application (issue [8] in PROGTOOLS-6993)
				if {[is_secure_domain $tgt]} {

					# Use local reset via MXCM33_CM33_CMD
					# Check MXCM33_CM33_CMD accessibility at both, secure and non-secure, addresses
					# since the cm33_s application or TFM could re-configure PROT_PERI0_SRSS_GENERAL2
					echo "Info : \[$tgt\] Using local reset (MXCM33_CM33_CMD) and Reset Vector Catch (VC_CORERESET)"
					set cmd_addr [addr_to_sorns $tgt $::MXCM33_CM33_CMD]
					if {[catch {read32 $tgt $cmd_addr}]} {
						echo "Info : \[$tgt] Cannot access MXCM33_CM33_CMD at [format 0x%x $cmd_addr], protection settings likely changed"
						set cmd_addr 0
						# TODO: After cm33_s or TFM changed the protection settings for the register to non-secure access,
						# but CM33 core is still in secure domain (we are debugging cm33_s app and did yet not pass execution to NonSecure_ResetHandler),
						# it looks we can't access this register neither by Secure nor by Non-Secure aliases - this causes fault exception
						# Worth playing more with this?
						# set cmd_addr [expr {[is_secure_addr $cmd_addr] ? [addr_to_ns $cmd_addr] : [addr_to_s $cmd_addr]}]
						# if {[catch {read32 $tgt $cmd_addr}]} {
						# 	echo "Info : \[$tgt\] Cannot access MXCM33_CM33_CMD register neither by Secure nor by Non-Secure aliases"
						# 	set cmd_addr 0
						# }
					}
					if {$cmd_addr} {
						set vc_catch [reset_halt_vector_catch $tgt $cmd_addr $::MXCMxx_CMxx_CMD_RESET]
						set is_s_reset_handler [expr {$vc_catch && [boot_to_s_reset_handler]}]
						if {!$is_s_reset_handler} {
							echo "Info : \[$tgt\] Cannot catch the reset handler"
						}
					}
				}

				# If local reset failed or was skipped, try SCB->AIRCR.SYSRESETREQ
				if {!$is_s_reset_handler} {
					echo "Info : \[$tgt\] Using system reset (AIRCR.SYSRESETREQ) and Reset Vector Catch (VC_CORERESET)"
					set vc_catch [reset_halt_vector_catch $tgt ]
					set sysrst_done 1
					set is_s_reset_handler [expr {$vc_catch && [boot_to_s_reset_handler]}]
					if {!$is_s_reset_handler} {
						echo "Info : \[$tgt\] Cannot catch the reset handler"
					}
				}
			}

			# If we could not reach S_Reset_Handler, either try restart mode or at least halt manually (worst case)
			set result $is_s_reset_handler
			if {!$result} {
				if {!$restart_done} {
					echo "Info : \[$tgt\] Cannot catch at Secure reset handler. Restart needed."
					set restart_needed 1
					break
				} else {
					echo "Warn : \[$tgt\] Cannot catch at Secure reset handler. Halting manually"
					if {[catch {$tgt arp_halt}] || ![poll_halted $tgt $timeout_max]} {
						puts stderr "Error: \[$tgt\] Cannot halt"
						break
					}
				}
			}
			if {!$ns_app_needed} { break }
			set result 0

			#######################################################################
			# CM33_NS app debugging - catch at the application's NS_Reset_Handler
			#######################################################################

			# If we are here, we are hunting for NS_Reset_Handler
			# At this point we must be at S_Reset_Handler of cm33_s user`s app
			# Or, in worst case, halted manually somewhere in cm33_s code

			# Resume and use watchpoint to catch VTOR update to NS address
			set vt_addr [expr {[read32 $tgt 0xE000ED08] & 0xFFFFFF80}]
			if {[is_secure_addr $vt_addr]} {
				log_debug "Resuming '$tgt' to catch VTOR for CM33 NS app"
				wp 0xE000ED08 4 w ; # Set a watchpoint for write access to VTOR
				set attempts 3    ; # Use several attempts since the secure app(s) may change the VTOR several times
				set t_end [expr {[clock milliseconds] + $timeout_app}]
				while {([clock milliseconds] < $t_end) && ($attempts > 0)} {
					resume					
					sleep 200 ; # Wait for some time to let the app running and openocd to finish events processing
					if {![poll_halted $tgt $timeout_app]} {
						echo "Warn : \[$tgt\] Not halted while watching for NS VTOR"
						break
					}
					set vt_addr [expr {[read32 $tgt 0xE000ED08] & 0xFFFFFF80}]
					log_debug_cpu_stat "Targets state at VTOR watchpoint hit:"
					if {![is_secure_addr $vt_addr]} {
						set result 1
						break
					}
					incr attempts -1
				}
				rwp all ; # Remove all watchpoints
			}

			if {$result} {
				set result 0
				# Once VTOR is updated to NS address, get the NS app entry address:
				#  VTOR -> [__s_vector_table_rw + 4] -> NS_Reset_Handler
				# Set the breakpoint at NS_Reset_Handler and resume again
				set vt_rst [expr {[read32 $tgt [expr {$vt_addr + 4}]] & ~1 }]
				if {$vt_addr == 0 || $vt_rst == 0 || [is_secure_addr $vt_addr] || [is_secure_addr $vt_rst]} {
					echo "Warn : \[$tgt\] Cannot find the entry point for cm33_ns application"
				} else {

					# When watchpoint catch VTOR change to NS address, the NS app may have already started
					# and executed a few operations in its Reset_Handler, allocating __ns_vector_table_rw
					set pc [expr {[dict values [$tgt get_reg pc]] & ~1 }]
					if {($pc > $vt_rst) && ($pc - $vt_rst < 100)} {
						log_debug_info [format "\[$tgt\] Missed entry point for %d bytes" [expr {$pc - $vt_rst}]]
						set result [move_to_reset_handler $tgt]

					} else {
						bp $vt_rst 2 hw ; # Set hardware breakpoint at reset handler
						resume
						sleep 200 ; # Wait a bit to let the app running and openocd to finish events processing
						set result [poll_halted $tgt $timeout_app]
						rbp $vt_rst ; # Clear breakpoint
					}
				}
			}

			if {$result} {
				echo "Info : \[$tgt\] Halted at Non-Secure reset handler"
			} elseif {!$restart_done} {
				echo "Info : \[$tgt\] Not halted at Non-Secure reset handler. Restart required"
				set restart_needed 1
			} else {
				echo "Warn : \[$tgt\] Cannot reach or halt at Non-Secure reset handler. Halting manually"
				if {[catch {$tgt arp_halt}] || ![poll_halted $tgt $timeout_max]} {
					echo "Warn : \[$tgt\] Still cannot halt"
				}
			}

			break
		}

		targets $tgt_backup
		pop_log_settings

		# Try restart mode if needed and did not restart before
		if {!$result && $restart_needed && !$restart_done} {
			set new_mode [expr {[string first "reset" $mode] != -1 \
				? [string map {"reset" "restart"} $mode] \
				: "$mode restart" }]
			set result [reset_halt_cm33 $new_mode]
		}

		if {$result} {
			if {$restart_done || $sysrst_done} {
				enable_cpu_cm55
			}
		} else {
			puts stderr "** Fail. Cannot initialize CM33 application debugging"
			puts stderr "** Ensure valid application is programmed and debug resources are not disabled or protected"
			puts stderr "** Ensure the boot code starts the CM33 application"
		}

		log_debug_cpu_stat
		log_proc_return $result
		return $result
	}

	# Reset and halt CM55 at the Reset Handler for debugging
	# Supported modes: reset|restart [attach|multi]
	# Note: Do not call this procedure directly from command line, use `reset_halt` instead
	proc reset_halt_cm55 { {mode reset} } {
		log_proc_entry

		# Check major configuration issues
		set result [expr {$::ENABLE_CM33 && $::ENABLE_CM55}]		
		if {!$::ENABLE_CM55} { puts stderr "Error: Use `set ENABLE_CM55 1` to enable the core for debugging"}
		if {!$::ENABLE_CM33} { puts stderr "Error: Cannot set CM55 core for debugging without CM33 core enabled: use `set ENABLE_CM33 1`"}
		if {!$result} {
			log_proc_return $result
			return $result
		}

		set is_multi_debug  [expr {[string first "multi"  $mode] != -1}]
		set is_attach_debug [expr {[string first "attach" $mode] != -1}]

		# Ignore first time (do not disturb target) for the following debug scenarios:
		# - Attach: do not disturb target that is already running
		# - Multi-Core (add CM55 to CM33): do not disturb target that was initialized by "cm33_s Debug Multicore" launch configuration
		# For next calls - do normal reset/restart for Attach and just move to reset handler for Multi-Core
		if {$is_multi_debug || $is_attach_debug} {
			global DEBUG_MULTI_CORE
			if {![info exists DEBUG_MULTI_CORE]} {
				set DEBUG_MULTI_CORE 1
				log_proc_return 1
				return 1
			}
		}

		# Prepare for start
		set tgt_backup [target current]
		set tgt $::CHIPNAME.cm55
		echo "Info : \[$tgt\] Initializing \`$mode\` debug"
		log_debug_cpu_stat
		targets $tgt
		set is_restart_mode [expr {[string first "restart" $mode] != -1}]
		set restart_needed $is_restart_mode
		set restart_done 0
		set result 1

		# Do reset_halt for cm33_ns application
		# It will perform a full restart with the target re-acquisition if needed
		if {$restart_needed} {
			set result [reset_halt cm33_ns restart]
			set restart_done 1
			set restart_needed 0
		}

		set ::do_not_touch_cm55 1
		push_log_settings
		while {$result} { ; # Loop is just to avoid multiple nestings
			set cm33 $::CHIPNAME.cm33
			set result 0

			# Set Vector Catch for CM55 core and resume CM33, expecting cm33_ns application will start cm55
			# This is the easiest way to start the CM55 application for debugging, but this will work only when
			# the CM33 core is halted before the `Cy_SysEnableCM55` call in cm33_ns			
			if {[$cm33 curstate] eq "halted"} {				
				echo "Info : \[$cm33\] Resuming to let CM33 application start CM55"
				$tgt cortex_m vector_catch reset
				targets $cm33				
				resume
				sleep 200
				targets $tgt
				if {[poll_halted $tgt $::TIMEOUT_USER_APP]} {
					if {![catch {set pc [expr {[dict values [$tgt get_reg pc]] & ~1 }]}]} {
						log_debug_cpu_stat
						if {$pc != $::CM55_ENDLESS_LOOP_ADDR} {
							set result 1
						}
					}
				}
			}

			# If CM33 resuming didn't work, do a Soft-reset + Vector Catch
			if {!$result} {

				# Use local reset via MXCM55_CM55_CMD
				# Check MXCM55_CM55_CMD accessibility at both, secure and non-secure, addresses
				# since the cm33_s application or TFM could re-configure PROT_PERI0_SRSS_GENERAL2.
				# Use AP-CM33 to reset CM55 core due to possible protection restrictions or potential issues if CM55 is resetting itself
				echo "Info : \[$tgt\] Not halted at reset handler"
				echo "Info : \[$tgt\] Using local reset (MXCM55_CM55_CMD) and Reset Vector Catch (VC_CORERESET)"
				set cmd_addr [addr_to_sorns $cm33 $::MXCM55_CM55_CMD]
				if {[catch {read32 $cm33 $cmd_addr}]} {
					echo "Info : \[$cm33] Cannot access MXCM55_CM55_CMD at [format 0x%x $cmd_addr], protection settings likely changed"
					set cmd_addr 0
				}
				if {$cmd_addr} {
					set result [reset_halt_vector_catch $tgt $cmd_addr $::MXCMxx_CMxx_CMD_RESET $cm33]
					if {!$result} {
						echo "Info : \[$tgt\] Cannot catch the reset handler"
					}
				}

				# If local reset failed, try SCB->AIRCR.SYSRESETREQ
				if {!$result} {
					echo "Info : \[$tgt\] Using system reset (AIRCR.SYSRESETREQ) and Reset Vector Catch (VC_CORERESET)"
					set result [reset_halt_vector_catch $tgt ]
				}
			}

			if {$result} {
				echo "Info : \[$tgt\] Halted at reset handler"
			} elseif {!$restart_done} {
				echo "Info : \[$tgt\] Not halted at reset handler. Restart required"
				set restart_needed 1
			} else {
				echo "Warn : \[$tgt\] Cannot reach or halt at reset handler. Halting manually"
				if {[catch {$tgt arp_halt}] || ![poll_halted $tgt $::TIMEOUT_USER_APP]} {
					echo "Warn : \[$tgt\] Still cannot halt"
				}
			}
			break
		}

		unset ::do_not_touch_cm55
		targets $tgt_backup
		pop_log_settings

		# Try restart mode if needed and did not restart before
		if {!$result && $restart_needed && !$restart_done} {
			set new_mode [expr {[string first "reset" $mode] != -1 \
				? [string map {"reset" "restart"} $mode] \
				: "$mode restart" }]
			set result [reset_halt_cm55 $new_mode]
		}

		if {!$result} {
			puts stderr "** Fail. Cannot initialize application debugging"
			puts stderr "** Ensure valid application is programmed and debug resources are not disabled or protected"
			puts stderr "** Ensure the boot code starts the CM33 application"
			puts stderr "** Ensure the CM33 application initializes and starts CM55"
		}

		log_debug_cpu_stat
		log_proc_return $result
		return $result
	}

	# Performs Soft-Reset & Vector Catch, expecting the target to halt at the reset handler
	# Procedure enables Reset Vector Catch (set DCB_DEMCR.VC_CORERESET) and issues soft reset
	# via SCB->AIRCR.SYSRESETREQ (by default) or via manually specified register
	# Note: Cannot use native `soft_reset_halt` procedure since it relies on VECTRESET and has small timings
	proc reset_halt_vector_catch {{tgt "current"} {rst_reg 0xE000ED0C} {rst_val 0x05FA0004} {tgt_rst_write "default"}} {
		log_proc_entry
		push_log_settings
		set ret 0

		# Check/refine default parameters
		if {$tgt eq "current"} {set tgt [target current]}
		set is_system_rst_reg [expr {($rst_reg & 0xE0000000) == 0xE0000000}]
		if {$is_system_rst_reg || ($tgt_rst_write eq "default")} {set tgt_rst_write $tgt}
		
		# Clear TST_MODE.TEST_MODE bit in case was left after acquisition
		# Enable Reset Vector Catch (set DCB_DEMCR.VC_CORERESET)
		# And issue soft reset via SCB->AIRCR.SYSRESETREQ or alternatively provided register
		catch {write32 $::CHIPNAME.sys $::TST_MODE 0}
		$tgt cortex_m vector_catch reset
		log_debug "Reseting: write32 $tgt_rst_write $rst_reg $rst_val"
		catch {write32 $tgt_rst_write $rst_reg $rst_val}

		# Handshake after reset and poll for halted state
		# Note: Useless to check DHCSR.S_RESET_ST bit since OpenOCD will read/clear this bit on polling
		if {[dap_handshake]} {
			if {[poll_halted $tgt]} {
				set ret 1
			} else { log_debug_wrng "\[$tgt\] Not halted after reset" }
		} else { log_debug_wrng "\[$tgt\] Cannot handshake after reset" }

		$tgt cortex_m vector_catch none
		$tgt arp_poll
		# $tgt arp_poll
		# poll      ; # Update target state in OpenOCD for all cores
		sleep 200 ; # Wait some time due to asynchronous events

		pop_log_settings
		log_debug_cpu_stat
		log_proc_return $ret
		return $ret
	}

	# Proceed from RRAM assets address range to S_Reset_Handler of CM33 user`s app
	# If in Extended boot (at its reset handler, or halted before listen window ends, or in IDLE loop)
	# Just resume with vector catch to halt at S_Reset_Handler of user`s app
	proc boot_to_s_reset_handler { { timeout 1000 } } {
		log_proc_entry
		push_log_settings

		set error 0
		set is_s_reset_handler 0
		set tgt_backup [target current]
		set tgt $::CHIPNAME.cm33
		targets $tgt

		# Initial verification and preparations:
		# - Examine - we are not sure about the current state
		# - Halt, if was not halted previously
		# - Check we are in Secure Domain
		if {![poll_examine $tgt $timeout]} {
			echo "Warn : \[$tgt\] Cannot examine target"
			set error 1
		} else {
			if {[$tgt curstate] ne "halted"} {
				halt
				if {![poll_halted $tgt $timeout]} {
					echo "Warn : \[$tgt\] Cannot halt target"
					set error 1
				}
			}
			if {!$error && ![is_secure_domain $tgt]} {
				log_debug "\[$tgt\] Non-Secure domain. Reset required to proceed to the Secure reset handler"
				set error 1
			}
		}

		# Check PC is in RRAM assets address range
		# E.g. in Extended boot at its reset handler, or halted before listen window ends, or in IDLE loop
		# If in boot, set Vector Catch and resume to catch at S_Reset_Handler of user`s app
		# Also clear the TEST_MODE bit in case was left after acquisition
		if {!$error} {
			set pc            [expr {[dict values [$tgt get_reg pc]] & ~1 }]
			set boot_addr_min [addr_to_s $::RRAM_MAIN_BASE_CBUS]
			set boot_addr_max [expr {$boot_addr_min + $::RRAM_MAIN_OFFSET}]
			set is_in_boot    [expr {$pc > $boot_addr_min && $pc < $boot_addr_max}]
			log_debug [format "\[$tgt\] pc: 0x%x, expected boot code address range: \[0x%x:0x%x\]" $pc $boot_addr_min $boot_addr_max]

			if {$is_in_boot} {
				log_debug "\[$tgt\] Resuming to catch at Secure reset handler"
				$tgt cortex_m vector_catch reset
				catch {write32 $::CHIPNAME.sys $::TST_MODE 0}
		
				resume
				if {[poll_halted $tgt $timeout]} {
					set pc [expr {[dict values [$tgt get_reg pc]] & ~1 }]
					if {($pc < $boot_addr_min) || ($pc > $boot_addr_max)} {
						set is_s_reset_handler 1
					}
				}

				$tgt cortex_m vector_catch none
				# poll ; # Update target state in OpenOCD
				# $tgt arp_poll

			# If not in RRAM boot area, but LR == 0xFFFFFFFF or 0xFEFFFFFF,
			# we must be at S_Reset_Handler or somewhere between S_Reset_Handler and main()
			} elseif {[expr {[dict values [$tgt get_reg lr]] & 0xFEFFFFFF}] == 0xFEFFFFFF} {
				set is_s_reset_handler [move_to_reset_handler $tgt]
			}

			if {$is_s_reset_handler} {
				echo "Info : \[$tgt\] Halted at Secure reset handler"
			} else {
				log_debug "\[$tgt\] Not halted at Secure reset handler"
			}
		}

		log_debug_cpu_stat
		targets $tgt_backup
		pop_log_settings
		log_proc_return $is_s_reset_handler
		return $is_s_reset_handler
	}

	# Sets PC to the application entry point using VTOR
	proc move_to_reset_handler { tgt } {
		log_proc_entry
		push_log_settings
		set ret 0

		# TODO: Worth checking LR==0xffffffff or 0xfeffffff ?
		# TODO: Worth recovering MSP from [VTOR] ?
		if {[$tgt curstate] ne "halted"} { catch {
			$tgt arp_halt
			poll_halted $tgt 500
		}}

		if {[$tgt curstate] eq "halted"} {
			if [ catch {
				set pc      [expr {[dict values [$tgt get_reg pc]] & ~1}]
				set vt_addr [expr {[read32 $tgt 0xE000ED08] & 0xFFFFFF80}]
				set vt_rst  [expr {[read32 $tgt [expr {$vt_addr + 4}]] & ~1}]
				log_debug   [format "\[$tgt\] pc: 0x%x, VT_addr: 0x%x, VT_rst: 0x%x" $pc $vt_addr $vt_rst]
				if {$pc < $vt_rst} {
					log_debug_wrng "\[$tgt\] PC is behind the reset handler address in Vector Table"
				}
				if {$pc != $vt_rst} {
					log_debug [format "\[$tgt\] Moving PC from 0x%x to 0x%x" $pc $vt_rst]
					$tgt set_reg "pc [expr {$vt_rst | 1}]"
				}
				set ret 1
			} msg ] { log_debug_wrng "\[$tgt\] Cannot read or set PC:\n$msg"}
		} else { log_debug_wrng "\[$tgt\] Cannot halt target" }

		pop_log_settings
		log_proc_return $ret
		return $ret
	}


	###########################################################################
	# Target low-level misc. operations
	###########################################################################

	# Defines the state (secure/non-secure) of the chip
	proc read_and_init_secure { tgt } {
		log_proc_entry

		set dap [$tgt cget -dap]
		set is_secure [is_secure_domain]

		if {$is_secure} {
			set secure_str "Secure"
			$dap apsel [$tgt cget -ap-num]
			$dap apcsw $::AP_CSW_S 0x4F000000
			$tgt configure -work-area-phys [addr_to_s $::WORKAREAADDR] -work-area-size $::WORKAREASIZE
		} else {
			set secure_str "Non-secure"
			$dap apsel [$tgt cget -ap-num]
			$dap apcsw $::AP_CSW_NS 0x4F000000
			$tgt configure -work-area-phys [addr_to_ns $::WORKAREAADDR] -work-area-size $::WORKAREASIZE
		}

		global $tgt.secure
		if {![info exists $tgt.secure] || $is_secure != [set $tgt.secure]} {
			echo "Info : \[$tgt\] Current domain secure state: $secure_str"
			set $tgt.secure $is_secure
		}
	
		log_proc_return $secure_str
	}


	###########################################################################
	# Device info
	###########################################################################

	# Decodes the life stage of the chip
	proc decode_lcs { bootrow } {
		log_proc_entry

		set bootrow [expr {$bootrow & 0x00000FFF}]

		set K [expr {3 << 0}]
		set P [expr {3 << 2}]
		set S [expr {3 << 4}]
		set N [expr {3 << 6}]
		set R [expr {3 << 8}]
		set B [expr {3 << 10}]

		set lcs_table [subst {
			{ "VIRGIN"             0 }
			{ "SORT"               [expr {$K}] }
			{ "PROVISIONED"        [expr {$K | $P}] }
			{ "NORMAL"             [expr {$K | $B}] }
			{ "NORMAL_NO_SECURE"   [expr {$K | $B | $N}] }
			{ "DEVELOPMENT"        [expr {$K | $P | $B}] }
			{ "PRODUCTION"         [expr {$K | $P | $B | $S}] }
			{ "RMA"                [expr {$K | $B | $R}] }
			{ "RMA"                [expr {$K | $B | $R | $N}] }
			{ "RMA"                [expr {$K | $P | $B | $S | $R}] }
			{ "RMA"                [expr {$K | $P | $R}] }
			{ "RMA"                [expr {$K | $P | $B | $R}] }
		}]

		set ret "CORRUPTED"
		foreach lcs $lcs_table {
			if {$bootrow == [lindex $lcs 1]} {
				set ret [lindex $lcs 0]
				break
			}
		}

		log_proc_return $ret
		return $ret
	}

	# Detects and displays the chip info (silicon info, boot version, lifecycle stage)
	proc display_chip_info { chipname {force no} } {
		log_proc_entry

		# Run info command inly once for each particular chip, unless forced
		global ${chipname}::info_runned
		if {[info exists ${chipname}::info_runned] && $force != "force" } return
		set ${chipname}::info_runned 1

		global DEVICE_ID_TO_ADDR
		global DEVICE_ID_MPN_ADDR
		global L0_VERSION_ADDR
		global L1_VERSION_ADDR
		global BOOT_STATUS
		global DECODED_LCS_DATA

		push_log_settings
		echo "***************************************"
		catch {
			set family [format "%03X" [read_unaligned $DEVICE_ID_TO_ADDR 2]]
			set siid [format "%04X" [read_unaligned $DEVICE_ID_MPN_ADDR 2]]
			set si_rev [format "%02X" [mrb [expr {$DEVICE_ID_TO_ADDR + 2}]]]
			set rev_major "0x0[string index $si_rev 0]"
			set rev_minor "0x0[string index $si_rev 1]"
			set rev_major_str [expr {$rev_major == 0 ? "?" : [format %c [expr {$rev_major + 0x40}]]}]
			set rev_minor_str [expr {$rev_minor == 0 ? "?" : [expr {$rev_minor - 1} ]}]
			echo "** Silicon: 0x$siid, Family: 0x$family, Rev.: 0x$si_rev (${rev_major_str}${rev_minor_str})"

			if {[info exists siid] && [dict exists $::MPN $siid] } {
				echo "** Detected Device: [lindex $::MPN($siid) 0]"
			} else {
				echo "** The connected device is not available in the device database"
			}
		}

		# L0_VERSION - ROM_BOOT
		catch {
			set major [mrb [expr {$L0_VERSION_ADDR + 0}]]
			set minor [mrb [expr {$L0_VERSION_ADDR + 1}]]
			set patch [read_unaligned [expr {$L0_VERSION_ADDR + 2}] 2]
			set build [read_unaligned [expr {$L0_VERSION_ADDR + 4}] 4]
			echo [format "** SROM Boot version: %d.%d.%d.%d" $major $minor $patch $build]
		}

		# L0_VERSION - RRAM_SE_BOOT
		catch {
			set major [mrb [expr {$L0_VERSION_ADDR + 8}]]
			set minor [mrb [expr {$L0_VERSION_ADDR + 9}]]
			set patch [read_unaligned [expr {$L0_VERSION_ADDR + 10}] 2]
			set build [read_unaligned [expr {$L0_VERSION_ADDR + 12}] 4]
			echo [format "** RRAM Boot version: %d.%d.%d.%d" $major $minor $patch $build]
		}

		# L1_VERSION - SE_RT_SERVICES_BASE
		catch {
			set major [mrb [expr {$L1_VERSION_ADDR + 0}]]
			set minor [mrb [expr {$L1_VERSION_ADDR + 1}]]
			set patch [read_unaligned [expr {$L1_VERSION_ADDR + 2}] 2]
			set build [read_unaligned [expr {$L1_VERSION_ADDR + 4}] 4]
			echo [format "** SE RT Services Base version: %d.%d.%d.%d" $major $minor $patch $build]
		}

		# L1_VERSION - SE_RT_SERVICES
		catch {
			set major [mrb [expr {$L1_VERSION_ADDR + 8}]]
			set minor [mrb [expr {$L1_VERSION_ADDR + 9}]]
			set patch [read_unaligned [expr {$L1_VERSION_ADDR + 10}] 2]
			set build [read_unaligned [expr {$L1_VERSION_ADDR + 12}] 4]
			echo [format "** SE RT Services version: %d.%d.%d.%d" $major $minor $patch $build]
		}

		# L1_VERSION - CM33_L1_BOOT
		catch {
			set major [mrb [expr {$L1_VERSION_ADDR + 16}]]
			set minor [mrb [expr {$L1_VERSION_ADDR + 17}]]
			set patch [read_unaligned [expr {$L1_VERSION_ADDR + 18}] 2]
			set build [read_unaligned [expr {$L1_VERSION_ADDR + 20}] 4]
			echo [format "** Extended Boot version: %d.%d.%d.%d" $major $minor $patch $build]
		}

		catch {
			set status_val [mrw $BOOT_STATUS]
			set status_str "None/Unknown ([format 0x%08X $status_val])"
			foreach val $::boot_status_codes {
				if {$status_val == [lindex $val 1] } { set status_str [lindex $val 0]; break }
			}
			echo "** Boot Status : $status_str"
		}

		catch {
			set lcs [decode_lcs [mrw $DECODED_LCS_DATA]]
			echo "** Life Cycle  : $lcs"
		}

		echo "***************************************"
		pop_log_settings
		log_proc_return
	}


	###########################################################################
	# Flash banks
	###########################################################################

	# Defines flash banks
	proc define_flash_banks {} {
		log_proc_entry

		if {$::ENABLE_CM33} {
			# CM33 supports Secure and Non-Secure modes
			set main_start [expr {$::RRAM_MAIN_BASE + $::RRAM_MAIN_OFFSET}]
			set main_size  [expr {$::RRAM_MAIN_SIZE - $::RRAM_MAIN_OFFSET + $::RRAM_MAIN_RECLAIMED}]
			# Usage: flash bank bank_id driver_name base_address size_bytes chip_width_bytes bus_width_bytes target [driver_options ...]
			flash bank $::CHIPNAME.cm33.main_ns cmsis_flash [addr_to_ns $main_start] $main_size 4 4 $::CHIPNAME.cm33 $::RRAM_FLASHLOADER 1024
			flash bank $::CHIPNAME.cm33.main_s  virtual     [addr_to_s  $main_start] $main_size 4 4 $::CHIPNAME.cm33 $::CHIPNAME.cm33.main_ns

			# Check the SMIF_BANKS variable for the SMIF (external flash) banks definition.
			# The variable  might be provided either via the command line parameters
			# or in qspi_config.cfg file (generated by qspi-configurator), like in the following example
			#	set SMIF_BANKS {
			#		0 {addr 0x60000000 size 0x4000000 psize 0x400 esize 0x40000}
			#		1 {addr 0x64000000 size 0x4000000 psize 0x400 esize 0x40000}
			#		2 {addr 0x70000000 size 0x4000000 psize 0x400 esize 0x40000}
			#		3 {addr 0x74000000 size 0x4000000 psize 0x400 esize 0x40000} }
			# Note: 'psize' and 'esize' are optional and not currently used for CAT1D
			catch {source [find qspi_config.cfg]}
			if {![info exists SMIF_BANKS]} {
				global SMIF_BANKS
			}

			if {[info exists SMIF_BANKS]} {
				set num_banks [array size SMIF_BANKS]
				set smif_bank_param ""
				if {$num_banks > 1} {
					set smif_bank_param "prefer_sector_erase"
				}
				if [catch {
					foreach {key value} [array get SMIF_BANKS] {
						# Usage: flash bank $_FLASHNAME cmsis_flash <addr:0> <size:0> 0 0 <target> <algorithm_elf> <stack_size> [prefer_sector_erase]
						set bank_id $::CHIPNAME.cm33.smif${key}
						flash bank ${bank_id}_ns cmsis_flash [addr_to_ns $value(addr)] $value(size) 4 4 $::CHIPNAME.cm33 $::QSPI_FLASHLOADER 0x800 {*}$smif_bank_param
						flash bank ${bank_id}_s  virtual     [addr_to_s  $value(addr)] $value(size) 4 4 $::CHIPNAME.cm33 ${bank_id}_ns
					}
				}] {
					puts stderr "Error: Error in parsing SMIF_BANKS definition"
				}
			}
		}

		log_proc_return
	}

	# Perform full chip erase
	proc erase_all {} {
		log_proc_entry

		if {$::ENABLE_CM33 && [is_cpu_ap_open $::CHIPNAME.cm33]} {
			echo "Erasing main flash bank..."
			flash erase_sector $::CHIPNAME.cm33.main_ns 0 last

			set erased_list [list]
			set banks [flash list]
			set banks_count [llength $banks]
			for {set i 0} { $i < $banks_count } { incr i } {
				set bank [lindex $banks $i]
				set bank_driver $bank(driver)
				set bank_name $bank(name)
				set ns_bank_addr [addr_to_ns $bank(base)]

				if {[string first ".smif" $bank_name] != -1 && [lsearch $erased_list $ns_bank_addr] == -1} {
					lappend erased_list $ns_bank_addr
					echo [format "Erasing flash bank \"%s\" @0x%08x ..." $bank_name $bank(base)]
					flash erase_sector $i 0 last
				}
			}

		} else {
			puts stderr "Warn : CM33 core is either disabled or not accessible, skipping erase_all procedure"
			puts stderr "       Use 'set ENABLE_CM33 1' to enable core and ensure debug enabled in policies"
		}

		log_proc_return
	}
	add_help_text erase_all "Erases all flash banks"

}

