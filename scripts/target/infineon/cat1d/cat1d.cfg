#
# Copyright (C) <2024-2025>
#   <Cypress Semiconductor Corporation (an Infineon company)>
#
# Main configuration script for CAT1D category of microcontrollers.

###############################################################################
# Include common misc scripts
###############################################################################

source [find mem_helper.tcl]
source [find target/swj-dp.tcl]
source [find target/cympn.cfg]
source [find target/infineon/common/common_arm.cfg]
source [find target/infineon/common/common_ifx.cfg]
namespace import arm::*
namespace import ifx::*

###############################################################################
# Target/setup identification
###############################################################################

set CATEGORY cat1d
set CHIPNAME $CATEGORY

if {![info exists SERIES]} {
	puts "Warn : Do not use this config directly."
	puts "Warn : Need to define the target explicitly:"
	puts "Info : Use: -c \"set SERIES <series_name>; \[set DEVICE <device_name>\]; \[set BOARD <board_name>\]\""
}

# Set default target identification variables, if not set externally.
# Supported variants for CAT1D:
#   SERIES | DEVICE     | BOARD         | Notes
#   -------+------------+----------------------------------------------------------------------
#   PSE84  | M0SEC      | n/a (Generic) | A0/B0, M0SEC
#   PSE84  | A0         | n/a (Generic) | A0, Pre-Production silicon
#   PSE84  | A0         | PSVP          | A0, Pre-Silicon Validation Platform
#   PSE84  | PSE84xGxS2 | n/a (Generic) | B0, EPC2, Total NVM: 512 KB, Programmable NVM: 356KB
#   PSE84  | PSE84xGxS4 | n/a (Generic) | B0, EPC4, Total NVM: 512 KB, Programmable NVM: 188KB
#   PSE84  | PSE84xGxS4 | PSVP          | B0, Pre-Silicon Validation Platform
#   pse86  | a0         | n/a (generic)
set_or_global SERIES  PSE84
set_or_global DEVICE  PSE84xGxS4
set_or_global BOARD   Generic

puts "***************************************"
puts "** SERIES:   $SERIES"
puts "** DEVICE:   $DEVICE"
puts "** BOARD:    $BOARD"
puts "***************************************"

if {[string compare -nocase $DEVICE "M0SEC"] == 0} {
	source [find [string tolower target/infineon/${CATEGORY}/${CATEGORY}_m0sec.cfg]]
	return
}

# Include the chain of the configuration files defining the setup.
# The low-level definitions (variables and procedures) may overwrite any of the
# higher-level definitions when needed. It is performed using the target
# identification global variables and in bottom to high order:
#   BOARD -> DEVICE -> SERIES -> CATEGORY
# These variables, except CATEGORY, are either provided externally (in the
# command line or board file) or set to defaults if not.

# Include memory and register definitions
catch {source [find [string tolower target/infineon/${CATEGORY}/memory_${CATEGORY}_${SERIES}_${DEVICE}_${BOARD}.cfg]]}
catch {source [find [string tolower target/infineon/${CATEGORY}/memory_${CATEGORY}_${SERIES}_${DEVICE}.cfg]]}
       source [find [string tolower target/infineon/${CATEGORY}/memory_${CATEGORY}_${SERIES}.cfg]]
       source [find [string tolower target/infineon/${CATEGORY}/memory_${CATEGORY}.cfg]]

# Include configuration variables
catch {source [find [string tolower target/infineon/${CATEGORY}/config_${CATEGORY}_${SERIES}_${DEVICE}_${BOARD}.cfg]]}
catch {source [find [string tolower target/infineon/${CATEGORY}/config_${CATEGORY}_${SERIES}_${DEVICE}.cfg]]}
       source [find [string tolower target/infineon/${CATEGORY}/config_${CATEGORY}_${SERIES}.cfg]]
       source [find [string tolower target/infineon/${CATEGORY}/config_${CATEGORY}.cfg]]

# Include functions/subroutines
catch {source [find [string tolower target/infineon/${CATEGORY}/func_${CATEGORY}_${SERIES}_${DEVICE}_${BOARD}.cfg]]}
catch {source [find [string tolower target/infineon/${CATEGORY}/func_${CATEGORY}_${SERIES}_${DEVICE}.cfg]]}
catch {source [find [string tolower target/infineon/${CATEGORY}/func_${CATEGORY}_${SERIES}.cfg]]}
       source [find [string tolower target/infineon/${CATEGORY}/func_${CATEGORY}.cfg]]
       source [find [string tolower target/infineon/cat1/func_cat1.cfg]]

# Import definitions from included namespaces
namespace import [string tolower ${CATEGORY}::${SERIES}::${DEVICE}::${BOARD}*]
namespace import [string tolower ${CATEGORY}::${SERIES}::${DEVICE}*]
namespace import [string tolower ${CATEGORY}::${SERIES}*]
namespace import [string tolower ${CATEGORY}::*]
namespace import cat1::*


###############################################################################
# Adapter and SWJ settings
###############################################################################

echo "transport: [transport select]"
echo "adapter name: [adapter name]"
adapter speed [expr { [using_jtag]? $::ADAPTER_SPEED_JTAG : $::ADAPTER_SPEED_SWD }]
adapter srst delay $::ADAPTER_SRST_DELAY
swj_newdap $CHIPNAME cpu -irlen $::SWJ_IRLEN -ircapture 0x1 -irmask 0xf -expected-id 0


###############################################################################
# Reset configuration
###############################################################################

# If acquisition in Test Mode (via SYS-AP or CM33-AP) is disabled, and both
# cores are disabled as well, so we can't even use SYSRESETREQ for `reset init`
# command, let's just use the SRST (XRES) pin for the 'reset run' command
# to be able to reset the device if only SYS-AP is opened
if {!$ENABLE_ACQUIRE && !$ENABLE_CM33 && !$ENABLE_CM55} {
	reset_config srst_only srst_gates_jtag
}

# Overrides default init_reset procedure, stores reset mode in global variable
proc init_reset { mode } {
	log_proc_entry
	set ::RESET_MODE $mode
	if {[using_jtag]} {
		jtag arp_init-reset
	}
	log_proc_return
}


###############################################################################
# Configure DAP
###############################################################################

dap create $CHIPNAME.dap -chain-position $CHIPNAME.cpu -adiv6 -power-down-on-quit
if {$ENABLE_ACQUIRE} {
	$CHIPNAME.dap configure -event init-post "event_dap_init_post"
	$CHIPNAME.dap configure -event init-fail "event_dap_init_fail"

	proc event_dap_init_post {} {
		log_proc_entry
		if {![info exists ::is_in_dap_init]} {
			set ::is_in_dap_init 1
			acquire_cat1d check_only
			catch {unset ::is_in_dap_init}
		}
		log_proc_return
	}

	proc event_dap_init_fail {} {
		log_proc_entry
		if {![info exists ::is_in_dap_init]} {
			set ::is_in_dap_init 1
			acquire_cat1d acquire_and_check
			catch {unset ::is_in_dap_init}
		}
		log_proc_return
	}
}

if {[using_jtag] && $::CPUTAPID != 0} {
	jtag newtap auto0 tap -irlen $::SWJ_IRLEN -expected-id $::CPUTAPID
}


###############################################################################
# Configure SYS-AP
###############################################################################

target create $CHIPNAME.sys mem_ap -dap $CHIPNAME.dap -ap-num $::AP_SEL_SYS

if {$ENABLE_ACQUIRE} {
	$CHIPNAME.sys configure -event reset-assert-pre "event_sys_reset_assert_pre"
	proc event_sys_reset_assert_pre {} {
		log_proc_entry
		if {$::RESET_MODE != "run"} {
			if {[info exists ::is_in_dap_init]} return
			set ::is_in_dap_init 1
			acquire_cat1d acquire_and_check
			catch {unset ::is_in_dap_init}
		}
		log_proc_return
	}
}

$CHIPNAME.sys configure -event examine-end "event_sys_examine_end"
proc event_sys_examine_end {} {
	log_proc_entry
	display_chip_info $::CHIPNAME
	log_proc_return
}


###############################################################################
# Configure CM33-AP and CM55-AP
###############################################################################

$CHIPNAME.dap apsel $::AP_SEL_SYS
$CHIPNAME.dap apcsw $::AP_CSW_S 0x0F000000

if {$ENABLE_CM33} {
	# TODO: Do we really need 'sys33' target?
	target create $CHIPNAME.sys33 mem_ap -dap $CHIPNAME.dap -ap-num $::AP_SEL_CM33
	target create $CHIPNAME.cm33 cortex_m -dap $CHIPNAME.dap -ap-num $::AP_SEL_CM33

	# Secure access by default
	$CHIPNAME.dap apsel $::AP_SEL_CM33
	$CHIPNAME.dap apcsw $::AP_CSW_S

	$CHIPNAME.cm33 cortex_m reset_config sysresetreq
	$CHIPNAME.cm33 configure -event examine-end "event_cm33_examine_end"
	$CHIPNAME.cm33 configure -event halted "event_cm33_halted"
	$CHIPNAME.cm33 configure -event reset-deassert-post "event_cm33_reset_deassert_post"
	# Default working area assuming CPU is in SECURE state
	# Later, it may be overwritten in the "read_and_init_secure" subroutine
	$CHIPNAME.cm33 configure -work-area-phys [addr_to_s $::WORKAREAADDR] -work-area-size $::WORKAREASIZE

	proc event_cm33_examine_end { } {
		log_proc_entry
		if {$::ENABLE_CM55} {
			enable_cpu_cm55_domain
		}
		log_proc_return
	}
	proc event_cm33_halted { } {
		log_proc_entry
		# Each time the CM33 core is halted, Read/store the secure domain flag and re-configure APCSW and WORKAREA accordingly
		read_and_init_secure $::CHIPNAME.cm33
		log_proc_return
	}
	proc event_cm33_reset_deassert_post { } {
		log_proc_entry
		enable_cpu
		log_proc_return
	}
	# Additional events used if the device requires the debug token (e.g. `event_cm33_reset_assert_debug_token`)
}

if {$ENABLE_CM55} {
	target create $CHIPNAME.cm55 cortex_m -dap $CHIPNAME.dap -ap-num $::AP_SEL_CM55
	$CHIPNAME.dap apsel $::AP_SEL_CM55
	$CHIPNAME.dap apcsw [expr {$::AP_CSW_NS | (1 << 28)}]

	$CHIPNAME.cm55 cortex_m reset_config sysresetreq
	$CHIPNAME.cm55 configure -event reset-assert {}
	$CHIPNAME.cm55 configure -event examine-end "event_cm55_examine_end"
	
	# Working area for CM55 is always NON-SECURE addresses
	$CHIPNAME.cm55 configure -work-area-phys [addr_to_ns $::WORKAREAADDR] -work-area-size $::WORKAREASIZE

	proc event_cm55_examine_end { } {
		log_proc_entry
		enable_cpu_cm55
		log_proc_return
	}
}


###############################################################################
# Misc. configuration
###############################################################################

define_flash_banks

kitprog3_acquire_config $TIMEOUT_RESET_HANDSHAKE

if {$ENABLE_CM33 && $ENABLE_CM55} {
	set _TARGETNAME0 $CHIPNAME.cm33
	set _TARGETNAME1 $CHIPNAME.cm55
} elseif {$ENABLE_CM33 && !$ENABLE_CM55} {
	set _TARGETNAME $CHIPNAME.cm33
} elseif {!$ENABLE_CM33 && $ENABLE_CM55} {
	set _TARGETNAME $CHIPNAME.cm55
}

# Set default Access Port
if {$ENABLE_CM33} {
	targets $CHIPNAME.cm33
} elseif {$ENABLE_CM55} {
	targets $CHIPNAME.cm55
}

log_debug "--- Config file processed ---"
