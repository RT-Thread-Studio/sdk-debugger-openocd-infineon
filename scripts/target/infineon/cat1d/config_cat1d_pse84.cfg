#
# Copyright (C) <2024-2025>
#   <Cypress Semiconductor Corporation (an Infineon company)>
#
# Default configuration file for cat1d-pse84 family of microcontrollers.
# The definitions can be overwritten from the device-specific configuration
# file(s)

###############################################################################
# CPU cores availability for the debugger and the acquisition methods
###############################################################################

set_or_global ENABLE_CM0                0
set_or_global ENABLE_CM33               1
set_or_global ENABLE_CM55               0
set_or_global ENABLE_ACQUIRE            1
set_or_global DEBUG_CERTIFICATE_ADDR    $SRAM_S_BASE

# Safe memory location for the endless loop instruction for CM55 initialization
set_or_global CM55_ENDLESS_LOOP_ADDR    0x3F0


###############################################################################
# Timings
###############################################################################

# Reset Handshake - timeout for the debugger to poll the DAP after reset until
# SWJ pins are enabled and the DAP can respond to simple requests such as
# "Read IDCODE".
# - For PSE84, this is the secure boot execution time, which includes an inte-
#   grity check for SE Services and Extended Boot and depends on their sizes.
#   Typically, it is <= 40ms, but the debugger uses 100ms to be on the safe side.
# For PowerCycle, timeout depends on the design schematic and must be longer.
set_or_global TIMEOUT_RESET_HANDSHAKE   100

# TODO: Validate *TIMEOUT* variables usage
set_or_global ACQUIRE_TIMEOUT           1000
set_or_global TIMEOUT_BOOT_COMPLETE     5000

# The additional timeout for the debugger to wait from when the SWJ pins became
# available to when the boot code starts the Listen Window.
# - For CAT1a, b, and c, this time is zero, since the boot code starts the
#   Listen Window immediately after SWJ pins are enabled.
# - For CAT1d (PSE84), this is the Extended Boot execution time until it starts
#   the Listen Window. It depends on the size and location of the next app to
#   be validated and loaded. 5000ms has to be enough for most scenarios.
set_or_global TIMEOUT_USER_APP          5000

###############################################################################
# DAP and TAPs settings
###############################################################################

set_or_global AP_SEL_SYS                0xF0000000
set_or_global AP_SEL_CM33               0xF0002000
set_or_global AP_SEL_CM55               0xF0006000
set_or_global AP_CSW_S                  0x0B000000 ; # SPROT=0 (S),  Priv=1
set_or_global AP_CSW_NS                 0x4B000000 ; # SPROT=1 (NS), Priv=1
set_or_global SWJ_IRLEN                 8
set_or_global CPUTAPID                  0 ; # Disable TAP for B0
set_or_global CPUID_CM33                0x411FD210
set_or_global CPUID_CM55                0x411FD221


###############################################################################
# Flash properties and working area
###############################################################################

# Offset for the RRAM_MAIN_NVM region to exclude the proprietary boot assets
# from programming operations. The offset must be increased for the projects,
# where the OEM Bootloader resides in flash.
set_or_global RRAM_MAIN_OFFSET          0x11000
# Size of the reclaimed area - address range in PROTECTED_NVM area, reclaimed
# as continuous address space following the MAIN_NVM and has the same MPC
# config as the user area in MAIN_NVM. The common reclaimed sizes are:
#   0KB   (0x00000) - for PSE84xGxS4 (EPC4 - Standard) device variant
#   168KB (0x2A000) - for PSE84xGxS2 (EPC2 - Lite) device variant
set_or_global RRAM_MAIN_RECLAIMED       0
# - Programmable RRAM flash banks are calculated as follows:
#   START = RRAM_MAIN_BASE (0x02000000) + RRAM_MAIN_OFFSET
#   SIZE  = RRAM_MAIN_SIZE (0x00040000) - RRAM_MAIN_OFFSET + RRAM_MAIN_RECLAIMED
# - The default programmable RRAM flash banks parameters:
#   EPC4: START = 0x22011000, SIZE = 0x59000 (356KB)
#   EPC2: START = 0x22011000, SIZE = 0x2F000 (188KB)
# - User may free-up 28KB (0x7000) at the start of the programmable RRAM region,
#   which increases the available memory:
#   EPC4: START = 0x2200A000, SIZE = 0x60000 (384KB)
#   EPC2: START = 0x2200A000, SIZE = 0x35000 (212KB)

# Flash programming algorithms and working area
set_or_global RRAM_FLASHLOADER          ../flm/cypress/cat1d/PSE84_RRAM_NVM.FLM
set_or_global QSPI_FLASHLOADER          ../flm/cypress/cat1d/PSE84_SMIF.FLM
set_or_global WORKAREAADDR              $SRAM_S_BASE
set_or_global WORKAREASIZE              $SRAM_SIZE


###############################################################################
# Adapter settings
###############################################################################

set_or_global ADAPTER_SPEED_JTAG        2000
set_or_global ADAPTER_SPEED_SWD         4000
set_or_global ADAPTER_SRST_DELAY        50

# KitProg3 acquisition sequence:         |- Target: 0xFE == Custom acquisition sequence for DAP Acquire (0x85) CMD
#                                        |   |- Set Acquire Parameters CMD (0x91)
#                                        |   |  Select DAP handshake type  (0x01)
#                                        |   |  JTAG to Dormant to SWD     (0x04)
#                                        |   |      |- SWD sequence
set_or_global KP3_ACQUIRE_TM_CMD        "254 910104 85FE000108A5A5A950000000B1F0000D00A30B0000028B52400400BB80000000BD"

###############################################################################
# Boot settings
###############################################################################

set_or_global BOOT_STATUS_ADDR          $SRAM_S_BASE
set_or_global BOOT_STATUS_LISTWND       0xAA00B5F8

# TODO: Avoid numbers hardcoding in the code if present in this dictionary
set_or_global boot_status_codes {
	{ CYBOOT_SUCCESS                            0x0D50B002 }
	{ CYBOOT_BAD_PARAM                          0xBAF00001 }
	{ CYBOOT_FAILED                             0xBAF00002 }
	{ CYBOOT_BOOTROW_CORRUPTED                  0xBAF00010 }
	{ CYBOOT_LCS_UNEXPECTED                     0xBAF00011 }
	{ CYBOOT_NVM_INIT_FAILED                    0xBAF00020 }
	{ CYBOOT_OTP_READ_FAILED                    0xBAF00021 }
	{ CYBOOT_OTP_WRITE_FAILED                   0xBAF00022 }
	{ CYBOOT_NVM_READ_FAILED                    0xBAF00023 }
	{ CYBOOT_NVM_WRITE_FAILED                   0xBAF00024 }
	{ CYBOOT_TOC1_INVALID                       0xBAF00025 }
	{ CYBOOT_TOC2_INVALID                       0xBAF00026 }
	{ CYBOOT_SHA256_CALC_FAILED                 0xBAF00027 }
	{ CYBOOT_ASSET_HASH_INVALID                 0xBAF00028 }
	{ CYBOOT_FACTORY_HASH_INVALID               0xBAF00029 }
	{ CYBOOT_SECURE_HASH_INVALID                0xBAF0002A }
	{ CYBOOT_PUB_KEY_ACCESS_FAILED              0xBAF00030 }
	{ CYBOOT_SIGNATURE_INVALID                  0xBAF00031 }
	{ CYBOOT_MEMORY_AREA_INVALID                0xBAF00032 }
	{ CYBOOT_TLV_INVALID                        0xBAF00033 }
	{ CYBOOT_TLV_NO_MORE_FOUND                  0xBAF00034 }
	{ CYBOOT_CLOCK_INIT_FAILED                  0xBAF00040 }
	{ CYBOOT_PWR_PROFILE_TRANSITION_FAILED      0xBAF00041 }
	{ CYBOOT_BISR_FAILED                        0xBAF00042 }
	{ CYBOOT_BASIC_TRIM_FAILED                  0xBAF00043 }
	{ CYBOOT_FULL_TRIM_FAILED                   0xBAF00044 }
	{ CYBOOT_SYSCPUSS_START_FAILED              0xBAF00045 }
	{ CYBOOT_PROT_MPC_CFG_FAILED                0xBAF00050 }
	{ CYBOOT_PROT_PPC_CFG_FAILED                0xBAF00051 }
	{ CYBOOT_WOUNDING_FAILED                    0xBAF00052 }
	{ CYBOOT_SAFE_MODE_ENTRY                    0x0D500060 }
	{ CYBOOT_DFT_EN_ENTRY                       0x0D500061 }
	{ CYBOOT_DLM_LOAD                           0x0D500070 }
	{ CYBOOT_DLM_VERIFY                         0x0D500071 }
	{ CYBOOT_DLM_RUN                            0x0D500072 }
	{ CYBOOT_DLM_PKG_INVALID                    0xBAF00073 }
	{ CYBOOT_DEBUG_TOKEN_LOAD                   0x0D500080 }
	{ CYBOOT_DEBUG_TOKEN_VALID                  0x0D500081 }
	{ CYBOOT_DEBUG_TOKEN_INVALID                0xBAF00082 }
	{ CYBOOT_DEBUG_POLICY_INVALID               0xBAF00083 }
	{ CYBOOT_CM33_L1_BOOT_INVALID               0xBAF00090 }
	{ CYBOOT_SE_RTS_BASE_INVALID                0xBAF00091 }
	{ CYBOOT_SE_RTS_INVALID                     0xBAF00092 }
}
