#
# Copyright (C) <2024-2025>
#   <Cypress Semiconductor Corporation (an Infineon company)>
#
# Common definitions and subroutines for Infineon microcontrollers.

source [find mem_helper.tcl]

namespace eval ifx {

	###############################################################################
	# Scripting automatization
	###############################################################################

	# Sets the global variable IF not defined earlier in config files or command line
	proc set_or_global {name value} {
		upvar $name glob_var
		if { ![info exists glob_var] } {
			set glob_var $value
		}
	}

	###############################################################################
	# Logging
	###############################################################################

	# Is debug log enabled
	# Note: Use 'set DEBUG_LOG 1' for more detailed logging.
	proc debug_log_enabled {} {
		global DEBUG_LOG
		variable log_push_count
		return [expr {[info exists DEBUG_LOG] && $DEBUG_LOG}]
	}

	variable log_push_count 0
	variable log_pushed_level 0

	# Push debug level
	proc push_log_settings { {force 0} } {

		if {[debug_log_enabled] && !$force} { return }
		variable log_push_count
		variable log_pushed_level

		if {$log_push_count == 0} {
			local_echo off
			scan [debug_level] "debug_level: %d" log_pushed_level
			debug_level -1
		}
		incr log_push_count
	}

	# Pop debug level
	proc pop_log_settings { {force 0} } {

		if {[debug_log_enabled] && !$force} { return }
		variable log_push_count
		variable log_pushed_level

		if { $log_push_count == 0 } {
			puts stderr "push/pop log settings mismatch"
		} else {
			incr log_push_count -1
		}

		if { $log_push_count == 0 } {
			debug_level $log_pushed_level
			local_echo on
		}
	}

	# Prints debug message if DEBUG_LOG enabled
	proc log_debug { msg } {
		if ![debug_log_enabled] return
		puts "Debug: $msg"
	}

	# Prints information message if DEBUG_LOG enabled
	proc log_debug_info { msg } {
		if ![debug_log_enabled] return
		puts "Info : $msg"
	}

	# Prints warning message if DEBUG_LOG enabled
	proc log_debug_wrng { msg } {
		if ![debug_log_enabled] return
		puts "Warn : $msg"
	}

	# Prints error message if DEBUG_LOG enabled
	proc log_debug_err { msg } {
		if ![debug_log_enabled] return
		puts stderr "Error: $msg"
	}

	# Prints CPUs statistic followed after optional messages if DEBUG_LOG enabled
	proc log_debug_cpu_stat { {msg ""} } {
		if ![debug_log_enabled] return
		if {$msg ne ""} {puts "Debug: $msg"}
		cpu_stat
	}

	# Logs procedure entry when the DEBUG_LOG = 1
	proc log_proc_entry {} {
		if ![debug_log_enabled] return

		set proc_level [expr {[info level ] -1}]
		set proc_name [lindex [info level -1] 0]
		set proc_name_short [string range $proc_name [expr {[string last ":" $proc_name] + 1}] end]
		set args_list {}

		if {![catch {set arg_names [info args $proc_name]}]} {
			set arg_vals [lrange [info level -1] 1 end]
			set arg_len  [llength $arg_names]
			for {set index 0} {$index < $arg_len} {incr index} {
				append args_list "[lindex $arg_names $index]='[lindex $arg_vals $index]'"
				if {$index < $arg_len - 1} { append args_list ", "}
			}
		}

		set caller_call_stack {}
		get_proc_trace caller_call_stack
		puts "-->\($proc_level\) $proc_name_short \($args_list\) \[[join $caller_call_stack { > }]\]"
	}

	# Logs procedure exit when the DEBUG_LOG = 1
	proc log_proc_return { {msg {}} } {
		if ![debug_log_enabled] return
		set proc_level [expr {[info level ] -1}]
		set proc_name [lindex [info level -1] 0]
		set proc_name_short [string range $proc_name [expr {[string last ":" $proc_name] + 1}] end]
		set caller_call_stack {}
		get_proc_trace caller_call_stack
		puts "<--\($proc_level\) $proc_name_short \($msg\) \[[join $caller_call_stack { > }]\]"
	}

	variable proc_trace {}

	# Gets procedures call trace
	proc get_proc_trace proc_trace_ref {
		upvar $proc_trace_ref proc_trace
		set start_level [expr {[info level] - 2}]
		for {set level 1} {$level <= $start_level} {incr level} {
			lappend proc_trace [lindex [info level $level] 0]
		}
	}


	###############################################################################
	# Targets processing
	###############################################################################

	# Returns polling status
	# Useful to store a backup before changing and further restoring with `eval poll $status`
	proc get_poll_status {} {
		push_log_settings
		scan [poll status] "background polling: %s" status
		pop_log_settings
		return $status
	}

	variable poll_push_count 0
	variable poll_init_status "unknown"

	# Push background polling status (poll on | off)
	# Set `poll off` at first call to disable backgroung polling for target status
	proc push_polling {} {
		variable poll_push_count
		variable poll_init_status
		if {$poll_push_count == 0} {
			set poll_init_status [get_poll_status]
			poll off
		}
		incr poll_push_count
	}

	# Pop background polling status (poll on | off)
	proc pop_polling {} {
		variable poll_push_count
		variable poll_init_status
		if {$poll_push_count == 0} {
			puts stderr "polling push/pop mismatch"
		} else {
			incr poll_push_count -1
		}

		if {$poll_push_count == 0 && $poll_init_status eq "on"} {
			poll on
		}
	}

	# Handshake and initialize DAP
	# Useful after reset (not absolutely necessary for SWD but must perform for JTAG)
	# or in case of some sticky failures
	proc dap_handshake { {timeout 0} } {
		log_proc_entry

		if {$timeout == 0} {
			if {[info exists ::TIMEOUT_RESET_HANDSHAKE]} { incr timeout $::TIMEOUT_RESET_HANDSHAKE }
			if {[info exists ::TIMEOUT_BOOT_COMPLETE]}   { incr timeout $::TIMEOUT_BOOT_COMPLETE   }
		}

		set ::is_in_dap_init 1
		push_log_settings
		push_polling

		log_debug "Handshake polling started with $timeout ms timeout"
		set ret 0; set t_start [ms]; set t_elapsed 0
		while 1 { # Execute at least once in case of a small timeout
			if {[catch {dap init}] == 0} {
				set ret 1
			}

			set t_elapsed [expr {[ms] - $t_start}]
			if {$ret || ($t_elapsed > $timeout)} { break }
			sleep 25
		}

		pop_polling
		pop_log_settings
		unset ::is_in_dap_init
		log_proc_return "$ret, elapsed $t_elapsed ms"
		return $ret
	}

	# Checks if Access Port is opened by reading the location of the ROM Table
	# This method is likely better than reading SCB->CPUID (0xE000ED00) since it should be faster,
	# does not involve memory read errors in case the AP is closed, and no need to care about clearing sticky errors
	# TODO: !!! UNDER CONSTRUCTION - DO NOT USE !!!
	#       This method supposed to be similar to 'is_ap_open_adiv6', but doesn't look working. Use 'is_cpu_ap_open' for now
	# Rename to 'is_ap_open' when ready and reuse in 20829.
	proc is_ap_open_test { tgt } {
		log_proc_entry
		push_log_settings
		push_polling

		set dap   [$tgt cget -dap]
		set apsel [$tgt cget -ap-num]
		set dbg_base {}
		set ret   [expr { [catch {
				set dbg_base [string trim [$dap apreg $apsel 0xDF8]]
				read32 $tgt $dbg_base
			}] ? 0 : 1 }
		]

		pop_polling
		pop_log_settings
		log_proc_return "$ret ($dbg_base)"
		return $ret
	}

	# Checks that CPU-AP is opened by reading SCB->CPUID
	proc is_cpu_ap_open { tgt } {
		log_proc_entry
		push_log_settings

		set ret 0
		if {[catch {$tgt arp_examine}] == 0} {
			set cpuid 0
			catch {read32 $tgt 0xE000ED00} cpuid
			if {$cpuid == $::CPUID_CM33 || $cpuid == $::CPUID_CM55} { set ret 1 }
		}

		pop_log_settings
		log_proc_return $ret
		return $ret
	}

	# Polls for CPU-AP opened by reading SCB->CPUID
	proc poll_cpu_ap_open { tgt { timeout 0 } } {
		log_proc_entry
		push_log_settings
		push_polling

		if {$timeout == 0} {
			if {[info exists ::TIMEOUT_RESET_HANDSHAKE]} { incr timeout $::TIMEOUT_RESET_HANDSHAKE }
			if {[info exists ::TIMEOUT_BOOT_COMPLETE]}   { incr timeout $::TIMEOUT_BOOT_COMPLETE   }
		}

		log_debug "\[$tgt\] Polling CPU-AP started with $timeout ms timeout"
		set ret 0; set t_start [ms]; set t_elapsed 0
		while 1 { # Execute at least once in case of a small timeout

			if [is_cpu_ap_open $tgt] {
				set ret 1
			}

			set t_elapsed [expr {[ms] - $t_start}]
			if {$ret || ($t_elapsed > $timeout)} { break }
			sleep 25

			# TODO: Check we indeed need 'dap init' here, especially for JTAG
			set ::is_in_dap_init 1
			catch {dap init}
			unset ::is_in_dap_init
		}

		pop_polling
		pop_log_settings
		log_proc_return "$ret, elapsed $t_elapsed ms"
		return $ret
	}

	# Examine target with polling for success
	# Required when the target configuration is still in process at the moment when debugger acquires the device
	proc poll_examine { tgt { timeout 0 } } {
		log_proc_entry
		push_log_settings
		push_polling

		if {$timeout == 0} {
			if {[info exists ::TIMEOUT_RESET_HANDSHAKE]} { incr timeout $::TIMEOUT_RESET_HANDSHAKE }
			if {[info exists ::TIMEOUT_BOOT_COMPLETE]}   { incr timeout $::TIMEOUT_BOOT_COMPLETE   }
		}

		log_debug "\[$tgt\] Polling examine started with $timeout ms timeout"
		set ret 0; set t_start [ms]; set t_elapsed 0
		while 1 { # Execute at least once in case of a small timeout
			if { ![catch {
				$tgt arp_examine
				$tgt arp_poll
				$tgt arp_poll
			}] } { set ret 1}

			set t_elapsed [expr {[ms] - $t_start}]
			if {$ret || ($t_elapsed > $timeout)} { break }
			sleep 25
		}

		pop_polling
		pop_log_settings
		log_proc_return "$ret, elapsed $t_elapsed ms"
		return $ret
	}

	# Waits for target halted
	# Uses `wait_halt` underlying method as an alternative to `arp_waitstate halted`
	# Since the last one causes a bottom-level exception that can't be caught in the script
	# to proceed with recovery steps if the target was not halted
	proc poll_halted { tgt { timeout 0 } } {
		log_proc_entry
		push_log_settings

		if {$timeout == 0} {
			if {[info exists ::TIMEOUT_RESET_HANDSHAKE]} { incr timeout $::TIMEOUT_RESET_HANDSHAKE }
			if {[info exists ::TIMEOUT_BOOT_COMPLETE]}   { incr timeout $::TIMEOUT_BOOT_COMPLETE   }
		}

		set cur_state [$tgt curstate]
		set t_start [ms]
		log_debug "\[$tgt\] Polling halted started with $timeout ms timeout"
		log_debug "\[$tgt\] Initial state: $cur_state"
		set ret [expr {$cur_state eq "halted"}]
		if {!$ret} {
			catch {$tgt arp_waitstate halted $timeout}
			set ret [expr {[$tgt curstate] eq "halted"}]
		}
		set t_elapsed [expr {[ms] - $t_start}]

		pop_log_settings
		log_proc_return "$ret, elapsed $t_elapsed ms"
		return $ret
	}

	# Prints the state of all Cortex cores and their main registers if the core is halted
	# Useful while preparing the target for debug
	proc cpu_stat {} {
		foreach tgt [target names] {
			if { [$tgt cget -type] eq "cortex_m" } {

				# Target Name, running State, and S/NS domain
				set s_tgt "$tgt"
				if { $tgt eq [target current] } { append s_tgt "*"}
				set state [$tgt curstate]
				if [catch {
					append s_tgt [expr {[is_secure_domain $tgt] ? "\t\[S\]" : "\t\[NS\]"}]
				}] {append s_tgt "\t\[?\]"}
				push_log_settings

				# CPU registers
				set str_regs ""
				if { $state eq "halted" } {
					catch {
						set regs [$tgt get_reg "pc msp lr xpsr"]
						foreach {name value} $regs {
							if {$str_regs ne ""} {append str_regs ", "}
							append str_regs "${name}: $value"
						}
					}
				}

				# VTOR and Vector Table essential entries
				# TODO: Move ARM Cortex definitions and functions to a separate script
				set str_vt  ""
				if {[catch {
					set vt_addr [expr {[read32 $tgt 0xE000ED08] & 0xFFFFFF80}]
					append str_vt [format "VT_addr: 0x%08x" $vt_addr]
				}]} { append str_vt "VT_addr:    unknown"} \
				elseif {[catch {
					set vt_sp  [read32 $tgt $vt_addr]
					set vt_rst [expr {[read32 $tgt [expr {$vt_addr + 4}]] & ~1}]
					append str_vt [format ", VT_rst: 0x%08x, VT_sp: 0x%08x" $vt_rst $vt_sp ]
				}]} { append str_vt ", VT_rst:    unknown, VT_sp:     unknown"}

				# Use `echo` instead of `puts` to print in both, console and telnet/gdb terminal
				echo [format " | %s\t%s\t%s%s%s" $s_tgt $state $str_regs [expr {$str_regs eq "" ? "" : ", "}] $str_vt]
				pop_log_settings
			}
		}
	}


	###############################################################################
	# Read/Write functions
	###############################################################################

	proc read32 { tgt addr } {
		return [$tgt read_memory $addr 32 1]
	}

	proc write32 { tgt addr val } {
		$tgt write_memory $addr 32 $val
	}

	proc write32_mask { tgt addr mask } {
		if ![ catch {set rvalue [$tgt read_memory $addr 32 1 phys] } msg ] {
			set value_or [expr {$rvalue | $mask}]
			write32 $tgt $addr $value_or
		} else {
			puts "Error: write32_mask: $msg"
		}
	}

	proc read_unaligned {addr size} {
		set result 0
		for {set i 0} {$i < $size} {incr i} {
			set result [expr {$result | ([mrb $addr] << (8 * $i))}]
			incr addr
		}

		return $result
	}


	###############################################################################
	# Security, TrustZone
	###############################################################################

	# Checks the "Current Domain Secure" (CDS) bit
	# in the "Debug Security Control and Status Register" (DSCSR)
	proc is_secure_domain { {tgt ""} } {
		if {$tgt eq ""} {set tgt [target current]}
		return [expr {([read32 $tgt 0xE000EE08] & (1 << 16)) != 0}]
	}

	# Checks the address is Secure (address[28] == '1') or Non-Secure (address[28] == '0')
	proc is_secure_addr { addr } {
		return [expr {($addr & 0x10000000) != 0}]
	}

	# Sets Secure or Non-Secure address, depending on "Current Domain Secure" (CDS) bit
	# in the "Debug Security Control and Status Register" (DSCSR)
	proc addr_to_sorns { tgt addr } {
		return [expr {[is_secure_domain $tgt] ? [addr_to_s $addr] : [addr_to_ns $addr]}]
	}

	# Sets Secure address (sets bit[28])
	proc addr_to_s { addr } {
		return [expr {$addr | 0x10000000}]
	}

	# Sets Non-Secure address (clears bit[28])
	proc addr_to_ns { addr } {
		return [expr {$addr & ~0x10000000}]
	}

}