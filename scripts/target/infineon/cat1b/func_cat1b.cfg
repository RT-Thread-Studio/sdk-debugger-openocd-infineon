#
# Copyright (C) <2024>
#   <Cypress Semiconductor Corporation (an Infineon company)>
#
# Subroutines for CAT1B category of microcontrollers.
# The definitions can be overwritten from the family-specific scripts.

namespace eval cat1b {

	namespace import ::arm::*
	namespace import ::ifx::*
	namespace import ::cat1::*

proc send_debug_certificate {} {
	global ACQUIRE_TIMEOUT
	global TIMEOUT_RESET_HANDSHAKE
	global WFA_TIMEOUT
	global DEBUG_CERTIFICATE
	set CERTIFICATE_ADDR  0x34004000

	# Hardware registers
	global BOOT_DLM_CTL
	global BOOT_DLM_CTL_2
	global BOOT_DLM_STATUS
	global RES_SOFT_CTL

	# Registers constants
	global RES_SOFT_CTL_RESET_RQST
	global TST_DBG_CTL_WAIT_RAM_APP_RQST
	global TST_DBG_CTL_WAIT_DBG_TOKEN_RQST
	global WFA_MASK

	# returns of BOOT_DLM_STATUS
	set CYBOOT_WFA_POLLING 0x0D500080
	set DEBUG_CER_VERIFICATION_SUCCESS 0x0D500084

	set old_target [target current]
	targets $::_TARGET_SYS
	select_current_ap

	mww $BOOT_DLM_CTL $TST_DBG_CTL_WAIT_DBG_TOKEN_RQST

	echo "issue software reset..."
	push_log_settings
	catch { mww $RES_SOFT_CTL $RES_SOFT_CTL_RESET_RQST }

	echo "Waiting for a WFA bit"
	set wfa_set 0
	set t_end [expr {[clock milliseconds] + $WFA_TIMEOUT}]
	while {[clock milliseconds] < $t_end} {
		if [catch {mrw $BOOT_DLM_CTL} ctl_status] continue
		if { ($ctl_status & $WFA_MASK) != 0} {
			set wfa_set 1
			break
		}
	}
	pop_log_settings

	if {!$wfa_set} {
		puts stderr "**FAIL: WFA bit was not set"
		return 1
	}

	# Set random value to check if BOOT_DLM_STATUS changed
	catch {mww $BOOT_DLM_STATUS 0x11223344}

	# Loading application
	puts "Programming debug token: $DEBUG_CERTIFICATE to $CERTIFICATE_ADDR"
	load_image $DEBUG_CERTIFICATE $CERTIFICATE_ADDR
	mww $BOOT_DLM_CTL_2 $CERTIFICATE_ADDR

	catch {mww $BOOT_DLM_CTL $TST_DBG_CTL_WAIT_DBG_TOKEN_RQST}

	# Sleep for a time of DAP reconnecting and verifying token
	sleep [expr {$TIMEOUT_RESET_HANDSHAKE + $WFA_TIMEOUT}]

	# Wait until BOOT_DLM_STATUS is changed to get status of token verification
	set status $CYBOOT_WFA_POLLING; set t_end [expr {[clock milliseconds] + $ACQUIRE_TIMEOUT}]
	while {$status == $CYBOOT_WFA_POLLING && [clock milliseconds] < $t_end} {
		if [catch {read32_adiv6 $::CHIPNAME.dap 0xF0000000 $BOOT_DLM_STATUS} status] continue
	}

	if {$status == $DEBUG_CER_VERIFICATION_SUCCESS} {
		echo "** Target acquired in WFA mode"
	} else {
		puts stderr "** Acquisition in WFA mode FAILED!"
	}


	set cm33_open 1
	#check if cm33 ap is enabled
	if { [is_ap_open_adiv6 $::CHIPNAME.dap 0xF0002000] == 0 } {
		puts stderr "** CM33 AP was not enabled"
		set cm33_open 0
	} else {
		echo "CM33 AP enabled"
	}

	if {$cm33_open} {
		$::_TARGET_CM33 arp_examine
		$::_TARGET_CM33 arp_poll
		$::_TARGET_CM33 arp_poll
	}

	if {!$cm33_open} {
		error {}
	}

	targets $old_target
	select_current_ap

	return 0
}

proc get_LCS {} {
	set BOOTROW_ADDR_SECURE 0x52610180
	set BOOTROW_ADDR_NONSECURE 0x42610180
	set lcsStr "UNKNOWN"

	#Try reading both S and NS aliases to get LCS
	if { [catch {read32_adiv6 $::CHIPNAME.dap 0xF0000000 $BOOTROW_ADDR_SECURE} lcs]} {
		if { [catch {read32_adiv6 $::CHIPNAME.dap 0xF0000000 $BOOTROW_ADDR_NONSECURE} lcs]} {
			return $lcsStr
		}
	}

	set lcs_hw [expr {$lcs & 0xFFFF}]
	set lcshex [format 0x%x $lcs_hw]

	switch $lcshex {
		0x0 {
			set lcsStr  "VIRGIN"
		}
		0x29 {
			set lcsStr  "SORT"
		}
		0xe9 {
			set lcsStr  "PROVISIONED";
		}
		0xc029 {
			set lcsStr  "NORMAL";
		}
		0xcc29 {
			set lcsStr  "NORMAL_NO_SECURE";
		}
		0xc0e9 {
			set lcsStr  "NORMAL_PROVISIONED";
		}
		0xc3e9 {
			set lcsStr  "SECURE";
		}
		0xf029 {
			set lcsStr  "RMA_NORMAL";
		}
		0xfc29 {
			set lcsStr  "RMA_NORMAL_NO_SECURE";
		}
		0xf3e9 {
			set lcsStr  "RMA_SECURE";
		}
	}
	return $lcsStr
}

# Gets boot status string out from code
# Note: don't change function name, dependence on the psc3 driver
proc get_boot_status_str {status_code} {
	set status_str "None/Unknown"
	foreach val $::boot_status_codes {
		if { $status_code == [lindex $val 1] } { set status_str [lindex $val 0]; break }
	}
	return $status_str
}

proc display_chip_info {chipname {force no} } {
	global ${chipname}::info_runned
	if { [info exists ${chipname}::info_runned] && $force != "force" } return
	set ${chipname}::info_runned 1

	set SIID_ADDR    0x13400000
	set FAMILY_ADDR  0x13400004
	set FB_VER_HI_ADDR 0x13401404
	set FB_VER_LO_ADDR 0x13401408
	set ROM_BOOT_VERSION_ADDR 0x1080FFF8
	set ROM_BOOT_BUILD_ADDR  0x1080FFFC
	set BOOT_STATUS_ADDR    0x52200418

	set FAMILY_MASK   0x0000FFFF
	set SIID_MASK     0xFFFF0000
	set SIID_REV_MASK 0x0000FF00

	catch {
		#LCS
		set lcs_str [get_LCS]
		if { $lcs_str != "VIRGIN" &&  $lcs_str != "SORT" &&  $lcs_str != "PROVISIONED"} {
			set SIID_ADDR    0x03400000
			set FAMILY_ADDR  0x03400004
		}
	}

	echo "***************************************"
	catch {
		# Si Id, Family & Rev.
		set si_id_raw [read32_adiv6 $::CHIPNAME.dap 0xF0000000 $SIID_ADDR]
		set si_id [expr {($si_id_raw & $SIID_MASK) >> 16 }]
		set si_rev [expr {($si_id_raw & $SIID_REV_MASK) >> 8 }]


		set CH_REV_MAJOR [expr {($si_rev >> 4) & 0x0F }]
		set CH_REV_MINOR [expr {$si_rev & 0x0F }]
		if {$CH_REV_MAJOR == 0} {
			set CH_REV_MAJOR 0x3F
		} else {
			set CH_REV_MAJOR [expr {$CH_REV_MAJOR + 0x40}]
		}

		if {$CH_REV_MINOR == 0} {
			set CH_REV_MINOR 0x3F
		} else {
			set CH_REV_MINOR [expr {$CH_REV_MINOR - 1}]
		}

		#si family
		set si_family [read32_adiv6 $::CHIPNAME.dap 0xF0000000 $FAMILY_ADDR]
		set si_family [expr {$si_family & $FAMILY_MASK }]

		#convert to DB style
		set si_id [format %X $si_id]
		echo [format "** Silicon: 0x%s, Family: 0x%03X, Rev.: 0x%02X (%c%X)" $si_id $si_family $si_rev $CH_REV_MAJOR $CH_REV_MINOR]
		if { [info exists si_id] && [dict exists $::MPN $si_id] } {
			echo "** Detected Device: [lindex $::MPN($si_id) 0]"
		} else {
			echo "** The connected device is not available in the device database"
		}

		# Set global Silicon id to get flash size from db
		set ::si_id_gl $si_id
	}

	catch {
		#ROM boot
		set rom_boot_ver [read32_adiv6 $::CHIPNAME.dap 0xF0000000 $ROM_BOOT_VERSION_ADDR]
		set rom_boot_build [read32_adiv6 $::CHIPNAME.dap 0xF0000000 $ROM_BOOT_BUILD_ADDR]
		set v_major [expr {($rom_boot_ver & 0x00FF0000) >> 16 }]
		set v_minor [expr {($rom_boot_ver & 0x0000FF00) >> 8 }]
		set v_patch [expr {$rom_boot_ver & 0x000000FF}]

		echo [format "** ROM Boot version: %d.%d.%d.%d" $v_major $v_minor $v_patch $rom_boot_build]
	}

	catch {
		#flash boot
		set version [read32_adiv6 $::CHIPNAME.dap 0xF0000000 $FB_VER_HI_ADDR]
		set build [read32_adiv6 $::CHIPNAME.dap 0xF0000000 $FB_VER_LO_ADDR]
		set fb_v_major [expr {($version & 0x00FF0000) >> 16 }]
		set fb_v_minor [expr {($version & 0x0000FF00) >> 8 }]
		set fb_v_patch [expr {$version & 0x000000FF}]

		echo [format "** Flash Boot version: %d.%d.%d.%d" $fb_v_major $fb_v_minor $fb_v_patch $build]
	}

	catch {
		set boot_code [read32_adiv6 $::CHIPNAME.dap 0xF0000000 $BOOT_STATUS_ADDR]
		set status_str "None/Unknown ([format 0x%08X $boot_code])"
		foreach val $::boot_status_codes {
			if { $boot_code == [lindex $val 1] } { set status_str [lindex $val 0]; break }
		}
		echo "** Boot Status : $status_str"
	}

	catch {
		echo "** Life Cycle: $lcs_str"
	}
	echo "***************************************"
}

proc acquire_test_mode {mode} {
	global BOOT_STATUS_ADDR
	global BOOT_STATUS_LISTWND
	global TIMEOUT_BOOT_COMPLETE
	global ACQUIRE_TIMEOUT
	set boot_code 0
	set result 1
	set rst_type_num 0

	targets $::_TARGET_SYS
	catch {$::_TARGET_SYS arp_examine}

	if {$mode == "acquire_and_check"} {
		# Preset status register
		catch {$::_TARGET_SYS mww $BOOT_STATUS_ADDR $boot_code}

		if {[adapter name] == "kitprog3" && ![using_jtag]} {
			# Standard acquisition flow using kitprog3 and swd
			# TODO: How to check Secure or Non-Secure address should be used here?
			set result [expr {![catch {kitprog3 acquire_psoc}]}]
		} else {
			# Try to Soft Acquire using XRES if implemented
			while {$rst_type_num != $::SOFT_TM_RESET_NUM} {
				set boot_status_upd $boot_code
				set rst_type_in_use [lindex $::SOFT_TM_RESET_TYPES $rst_type_num]
				set result [acquire_in_soft_mode $rst_type_in_use]

				set t_end [expr {[clock milliseconds] + $TIMEOUT_BOOT_COMPLETE}]
				if [ catch {
					while {[clock milliseconds] < $t_end} {
						set boot_status_upd [$::_TARGET_SYS read_memory $BOOT_STATUS_ADDR 32 1]
					}
				} ] {
					echo [format "Warn : Can't read boot status @0x%08X" $BOOT_STATUS_ADDR]
				}

				if {!$boot_status_upd} {
					puts stderr "**Reset Failed: $rst_type_in_use"
					incr rst_type_num
				} else {
					# Boot status changed, reset and boot occured
					break;
				}
			}
		}
		set mode "check_only"
	}

	if {$mode == "check_only" && $result == 1} {
		sleep [scan [adapter srst delay] "adapter srst delay: %d"]

		$::_TARGET_SYS arp_examine

		# Poll for acknowledge code
		set result 0
		set t_end [expr {[clock milliseconds] + $ACQUIRE_TIMEOUT}]
		set boot_code_last $boot_code
		if [ catch {
			while {[clock milliseconds] < $t_end} {
				set boot_code [$::_TARGET_SYS read_memory $BOOT_STATUS_ADDR 32 1]
				if {$boot_code_last != $boot_code} {
					echo [format "Info : Boot status \[0x%08X: 0x%08X\]" $BOOT_STATUS_ADDR $boot_code]
					set boot_code_last $boot_code
				}
				if {$boot_code == $BOOT_STATUS_LISTWND} {
					set result 1
					break
				}
			}
		} ] {
			echo [format "Warn : Can't read boot status @0x%08X" $BOOT_STATUS_ADDR]
		}
	}

	if {$result} {
		echo "** Target acquired in Test Mode"
	} else {
		puts stderr "** Acquisition in Test Mode FAILED!"
	}

	catch {acquire_in_wfa_mode}

	if {$::ENABLE_CM33} {
		targets $::_TARGET_CM33
	}
}

proc acquire_in_soft_mode {res_type} {
	echo "** Attempting to soft-acquire chip in Test Mode using reset $res_type..."
	local_echo off

	global TIMEOUT_RESET_HANDSHAKE
	global TIMEOUT_BOOT_COMPLETE
	global RES_SOFT_CTL
	global RES_SOFT_CTL_RESET_RQST

	switch $res_type {
		"XRES" {
			# Prereset - do hardware reset (XRES)
			# And handshake - wait while SWJ pins are enabled after the reset so we can connect to DAP
			reset_config srst_only; adapter assert srst; sleep 100; adapter deassert srst; reset_config none
		}
		"SOFT" {
			catch { mww $RES_SOFT_CTL $RES_SOFT_CTL_RESET_RQST }
		}
		default {
			reset_config srst_only; adapter assert srst; sleep 100; adapter deassert srst; reset_config none
		}
	}

	set result 0; set t_end [expr {[ms] + $TIMEOUT_RESET_HANDSHAKE}]
	while {[ms] < $t_end} {
		if {[catch {dap init}] == 0} {
			set result 1; break
		}
	}
	local_echo on

	set result 0; set t_end [expr {[ms] + $TIMEOUT_BOOT_COMPLETE}]
	while {[ms] < $t_end} {
		if {[catch {mww $::TST_MODE_REQ $::TST_MODE}] == 0} {
			set result 1; break
		}
	}

	return $result
}

proc acquire_in_wfa_mode {} {
	global DEBUG_CERTIFICATE
	set token [expr {[info exists DEBUG_CERTIFICATE] && [file exists $DEBUG_CERTIFICATE]}]

	if {$::ENABLE_CM33} {
		if {[is_ap_open_adiv6 $::CHIPNAME.dap 0xF0002000] == 0  } {

		$::_TARGET_CM33 configure -defer-examine
			
			if {$token} {
				echo "** Sending debug certificate"
				if [catch {send_debug_certificate}] {
					puts stderr "** Error sending debug certificate, examination skipped"
				} else {
					$::_TARGET_CM33 configure -event reset-deassert-post "event_cm33_reset_deassert_post"
				
					$::_TARGET_CM33 configure -event reset-deassert-pre {
						catch {send_debug_certificate}
						read_and_init_secure
					}
				}
			} else {
					puts stderr "** CM33 AP is closed and no certificate specified, examination skipped"
					puts stderr "** Use 'DEBUG_CERTIFICATE' variable to specify certificate filename with full path"
					exit 0;
			}
		} else {
			$::_TARGET_CM33 configure -event reset-deassert-post "event_cm33_reset_deassert_post"
		}
	}
}

proc read32_adiv6 { dap ap address } {
	push_log_settings
	catch {
		$dap apreg $ap 0xD00 0xAB000002
		$dap apreg $ap 0xD04 $address
		$dap apreg $ap 0xD0C
	} result options
	pop_log_settings
	return {*}$options [string trim $result]
}

proc write32_adiv6 { dap ap address val } {
	$dap apreg $ap 0xD00 0xAB000002
	$dap apreg $ap 0xD04 $address
	$dap apreg $ap 0xD0C $val
}

proc is_ap_open_adiv6 { {dap {}} {ap {}} } {
	push_log_settings
	scan [poll status] "background polling: %s" poll_status
	poll off

	set ret 0
	# read location of the ROM Table to check if AP is opened
	if ![catch {
			set dbg_base [string trim [$dap apreg $ap 0xDF8]]
			read32_adiv6 $dap $ap $dbg_base
		}] {
		set ret 1
	}

	eval poll $poll_status
	pop_log_settings
	return $ret
}

proc define_flash_banks_psc3 {} {
	# TODO: should we define 'main0_s' and 'super_ns' as virtual banks? This looks reasonable, but what side effects are possible if not?
	# TODO: Do we really need C-BUS aliases defined as flash banks in openocd?
	# Ref. https://jiracc.intra.infineon.com/browse/DRIVERS-16914

	flash bank ${::_TARGET_CM33}.main0_s        $::FLASH_DRIVER_NAME 0x32000000 0 0 0 $::_TARGET_CM33
	flash bank ${::_TARGET_CM33}.main0_ns       $::FLASH_DRIVER_NAME 0x22000000 0 0 0 $::_TARGET_CM33
	flash bank ${::_TARGET_CM33}.main0_cbus_s   virtual 0x12000000 0 0 0 $::_TARGET_CM33 ${::_TARGET_CM33}.main0_s
	flash bank ${::_TARGET_CM33}.main0_cbus_ns  virtual 0x02000000 0 0 0 $::_TARGET_CM33 ${::_TARGET_CM33}.main0_ns

	flash bank ${::_TARGET_CM33}.super_s        $::FLASH_DRIVER_NAME 0x33400000 0x8000 0 0 $::_TARGET_CM33
	flash bank ${::_TARGET_CM33}.super_ns       $::FLASH_DRIVER_NAME 0x23400000 0x8000 0 0 $::_TARGET_CM33
	flash bank ${::_TARGET_CM33}.super_cbus_s   virtual 0x13400000 0x8000 0 0 $::_TARGET_CM33 ${::_TARGET_CM33}.super_s
	flash bank ${::_TARGET_CM33}.super_cbus_ns  virtual 0x03400000 0x8000 0 0 $::_TARGET_CM33 ${::_TARGET_CM33}.super_ns
}

proc is_secure {} {
	# Read "Debug Security Control and Status Register" (DSCSR)
	# and check "Current Domain Secure" (CDS) bit
	set DSCSR [mrw 0xE000EE08]
	set _is_secure [expr {($DSCSR & (1 << 16)) != 0}]
	return $_is_secure
}

proc select_current_ap {} {
	variable dap
	variable ap

	set target [target current]
	set dap [$target cget -dap]
	set ap  [$target cget -ap-num]
}

proc read_and_init_secure {} {
	set tgt [target current]
	set dap [$tgt cget -dap]
	set _is_secure [is_secure]

	if {$_is_secure} {
		#puts "CPU is in secure State"
		# SPROT=0=Secure access, Priv=1
		set secure_str "Secure"
		$dap apsel [$tgt cget -ap-num]
		$dap apcsw 0x0B000000 0x4F000000
		$tgt configure -work-area-phys [addr_to_s $::WORKAREAADDR] -work-area-size $::WORKAREASIZE
	} else {
		#puts "CPU is in not-secure State"
		# SPROT=1=Non Secure access, Priv=1
		set secure_str "Non-secure"
		$dap apsel [$tgt cget -ap-num]
		$dap apcsw 0x4B000000 0x4F000000
		$tgt configure -work-area-phys [addr_to_ns $::WORKAREAADDR] -work-area-size $::WORKAREASIZE
	}

	global $tgt.secure
	if {![info exists $tgt.secure] || $_is_secure != [set $tgt.secure]} {
		echo "Info : \[$tgt\] Current domain secure state: $secure_str"
		set $tgt.secure $_is_secure
	}
}

proc update_flash_size_from_devicedb {} {
	global MPN
	# Set flash banks size from MPN db
	if {[info exist ::si_id_gl]} {
		set si_id $::si_id_gl
		if { [dict exists $MPN $si_id] } {
			set flash_size [lindex $MPN($si_id) 2]

			if {[string is integer -strict $flash_size]} {
				catch {$::FLASH_DRIVER_NAME set_banks_size $flash_size}
			}
		}
	}
}

###############################################################################
# Perform full chip erase
###############################################################################
proc erase_all {} {
	puts "Erasing entire flash.."
	lset banks [flash list]
	set banks_count [llength $banks]
	for {set i [expr {$banks_count - 1}]} { $i >= 0 } { incr i -1 } {
		set bank [lindex $banks $i]
		set bank_driver $bank(driver)
		set bank_name $bank(name)

		# Full chip erase is done via Non-secure alias
		# SFlash, virtual and secure flash banks skipped
		if { $bank_driver != "virtual" && [string first "super" $bank_name] == -1 && [string first "_ns" $bank_name] != -1} {
			echo [format "Erasing flash bank \"%s\"..." $bank_name]
			flash erase_sector $i 0 last
		}
	}
}
add_help_text erase_all "Erases all non-virtual flash banks"


}
