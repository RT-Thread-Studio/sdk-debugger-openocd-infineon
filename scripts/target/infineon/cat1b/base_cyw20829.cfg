#
# Copyright (C) <2019-2021>
#   <Cypress Semiconductor Corporation (an Infineon company)>
#
# Common configuration for CYW20829 family of microcontrollers.
#
###############################################################################
# Include common misc scripts
###############################################################################

source [find mem_helper.tcl]
source [find target/swj-dp.tcl]
source [find target/infineon/common/common_arm.cfg]
source [find target/infineon/common/common_ifx.cfg]
namespace import arm::*
namespace import ifx::*

set CATEGORY cat1b
set SERIES cyw20829
set_or_global CHIPNAME cyw20829
set FLASH_DRIVER_NAME cyw20829
set ${CHIPNAME}::TARGET_VARIANT $TARGET_VARIANT
###############################################################################
# Target/setup identification
###############################################################################

# Include the chain of the configuration files defining the setup.
# The low-level definitions (variables and procedures) may overwrite any of the
# higher-level definitions when needed. It is performed using the target
# identification global variables and in bottom to high order:
#   SERIES -> CATEGORY

# Include memory and register definitions
catch { source [find target/infineon/${CATEGORY}/memory_${CATEGORY}_${SERIES}.cfg] }
		source [find target/infineon/${CATEGORY}/memory_${CATEGORY}.cfg]

# Include configuration variables
catch { source [find target/infineon/${CATEGORY}/config_${CATEGORY}_${SERIES}.cfg] }
		source [find target/infineon/${CATEGORY}/config_${CATEGORY}.cfg]

# Include functions/subroutines
catch { source [find target/infineon/${CATEGORY}/func_${CATEGORY}_${SERIES}.cfg]}
		source [find target/infineon/${CATEGORY}/func_${CATEGORY}.cfg]
		source [find target/infineon/cat1/func_cat1.cfg]

# Import definitions from included namespaces
namespace import ${CATEGORY}::${SERIES}*
namespace import ${CATEGORY}::*
namespace import cat1::*


global TARGET
set TARGET $CHIPNAME

###############################################################################
# Adapter and SWJ settings
###############################################################################

set_adapter_options
define_kitprog3_acquire_options ${FLASH_DRIVER_NAME}
swj_newdap $CHIPNAME cpu -irlen $::SWJ_IRLEN -ircapture 0x1 -irmask 0xf

###############################################################################
# Configure DAP
###############################################################################
dap create $TARGET.dap -chain-position $TARGET.cpu -adiv5 -power-down-on-quit

if {[using_jtag]} {
	swj_newdap $TARGET bs -irlen $::SWJ_IRLEN
}

###############################################################################
# Configure SYS-AP
###############################################################################
target create ${TARGET}.sysap  mem_ap   -dap $CHIPNAME.dap -ap-num 0 -coreid 255
# Turn on hprot[0] bit in SysAP's AP->CSW register to allow data writes via SysAP
$TARGET.dap apsel 0
$TARGET.dap apcsw [expr {1 << 24}]
${TARGET}.sysap configure -event examine-end [subst -nocommands {
	display_chip_info $FLASH_DRIVER_NAME
}]

${TARGET}.sysap configure -event reset-assert {
	# This is the main Reset procedure, built-ins are overridden
	if { $::RESET_MODE eq "run" } {
		toggle_xres
		return
	}

	acquire_xres
# TODO: Keep it for a while, maybe WFA->TEST_MODE request will be implemented
# TODO: if { ![acquire_xres] && ![acquire_wfa $TEST_MODE_REQ_HERE] } {}
}

###############################################################################
# Configure CM33-AP
###############################################################################

target create ${TARGET}.cm33ap mem_ap   -dap $CHIPNAME.dap -ap-num 1 -coreid 255
target create ${TARGET}.cm33   cortex_m -dap $CHIPNAME.dap -ap-num 1 -coreid 0
${TARGET}.cm33 configure -work-area-phys $WORKAREAADDR -work-area-size $WORKAREASIZE

# Only SRST reset works correctly, SYSRESETREQ + VC_CORERESET causes debug pins been
# left disconnected due to known silicon design limitation
reset_config srst_only
${TARGET}.cm33ap configure -event reset-assert {}
${TARGET}.cm33 configure -event reset-assert {}
${TARGET}.cm33 configure -event reset-deassert-post "mxs40v2_reset_deassert_post ${TARGET}.cm33"

$CHIPNAME.dap configure -event init-fail [subst -nocommands {
	puts stderr "** DAP is not accessible, trying to acquire in Test Mode"
	if { ![acquire_xres $CHIPNAME.dap 0] } {
		puts stderr "** Target initialization failed (check connection, power, transport, DAP is enabled etc.)"
		terminate
	}
}]

proc find_core { suffix } {
	set t [target current]
	set sep [string last "." $t]
	return [string range $t 0 [expr {$sep - 1}]].$suffix
}

${TARGET}.cm33ap configure -event examine-end {
	global DEBUG_CERTIFICATE

	set target [target current]
	set cm33_target [string map {cm33ap cm33} $target]
	set sysap_target [string map {cm33ap sysap} $target]

	if { ![is_ap_open] } {
		if [info exists DEBUG_CERTIFICATE] {
			echo "** CM33 AP is closed, sending debug certificate"
			if [catch {send_certificate}] {
				puts stderr "** Error sending debug certificate, examination skipped"
				$cm33_target configure -defer-examine
				targets $sysap_target
				return
			}
		} else {
			puts stderr "** CM33 AP is closed and no certificate specified, examination skipped"
			puts stderr "** Use 'DEBUG_CERTIFICATE' variable to specify certificate filename with full path"
			$cm33_target configure -defer-examine
			targets $sysap_target
			return
		}
	}

	# make sure CM33 is examined without need for "reset init"
	if {[$cm33_target cget -defer-examine] == 0} {
		targets $cm33_target
		$cm33_target arp_examine
		$cm33_target arp_poll
		$cm33_target arp_poll
	}
}


###############################################################################
# SMIF (QSPI) flash bank
###############################################################################

# example of qspi_config.cfg
#set SMIF_BANKS {
#  0 {addr 0x60000000 size 0x10000 psize 0x100 esize 0x1000}
#  1 {addr 0x60010000 size 0x10000 psize 0x100 esize 0x1000}
#  2 {addr 0x60020000 size 0x10000 psize 0x100 esize 0x1000}
#  3 {addr 0x60030000 size 0x10000 psize 0x100 esize 0x1000}
#}

catch {source [find qspi_config.cfg]}
if { [info exists SMIF_BANKS] } {

	set num_banks [array size SMIF_BANKS]
	set bank_param ""
	if { $num_banks > 1 } {
		set bank_param "prefer_sector_erase"
	}

	# flash bank <bank_id> <driver_name> <base_address> <size_bytes> <chip_width_bytes> <bus_width_bytes> <target> [driver_options ...]
	# cmsis_flash driver options: <algorithm_elf> <stack_size> [prefer_sector_erase]
	foreach {key value} [array get SMIF_BANKS] {
		if { $value(addr) < 0x60000000 || [expr {$value(addr) + $value(size)}] > 0x68000000 } {
			puts stderr "** Flash bank ${CHIPNAME}_smif${key}_cm33 crosses XIP address region!"
			continue
		}

		flash bank ${CHIPNAME}_smif${key}_cm33 cmsis_flash $value(addr) $value(size) 4 4 ${TARGET}.cm33 $QSPI_FLASHLOADER 0x800 {*}$bank_param
		add_verify_range ${TARGET}.cm33 $value(addr) $value(size)

		set virtual_addr [expr {$value(addr) - 0x58000000}]
		flash bank ${CHIPNAME}_smif${key}_cbus virtual $virtual_addr $value(size) 4 4 ${TARGET}.cm33 ${CHIPNAME}_smif${key}_cm33
		add_verify_range ${TARGET}.cm33 $virtual_addr $value(size)
	}
}

gdb_smart_program enable

###############################################################################
# Target info
###############################################################################
proc check_flashboot_version {} {
# TODO: Implement check_flashboot_version. Check the same function in psoc6_common.cfg
}

